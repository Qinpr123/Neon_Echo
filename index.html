<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éœ“è™¹å›å£° - Neon Echo</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #050505;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
            cursor: crosshair;
        }
        canvas { display: block; }
        .ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            text-align: center; z-index: 10;
        }
        .hidden { display: none !important; }
        .hud {
            position: absolute; top: 16px; left: 16px;
            pointer-events: none; text-align: left;
        }
        .hud-score { color: #00f2ff; font-size: 18px; }
        .hud-best { color: #555; font-size: 11px; margin-top: 2px; }
        .hud-hp-wrap { margin-top: 8px; }
        .hud-hp-bg {
            width: 140px; height: 10px;
            background: rgba(255,255,255,0.08);
            border-radius: 5px; overflow: hidden;
            border: 1px solid rgba(255,34,102,0.3);
        }
        .hud-hp-fill {
            height: 100%; width: 100%;
            background: linear-gradient(90deg, #ff2266, #ff6688);
            transition: width 0.15s ease-out;
            border-radius: 5px;
        }
        .hud-hp-label {
            color: rgba(255,34,102,0.6); font-size: 9px;
            margin-top: 2px; letter-spacing: 2px;
        }
        .energy-wrap {
            position: absolute; bottom: 28px; left: 50%; transform: translateX(-50%);
            width: 200px; text-align: center;
        }
        .energy-bar-bg {
            width: 100%; height: 8px;
            background: rgba(255,255,255,0.08);
            border-radius: 4px; overflow: hidden;
            border: 1px solid rgba(255,255,255,0.15);
        }
        .energy-bar-fill {
            height: 100%; width: 100%;
            background: linear-gradient(90deg, #00f2ff, #00c3ff);
            transition: width 0.08s linear;
            box-shadow: 0 0 8px #00f2ff;
        }
        .energy-label {
            color: rgba(0,242,255,0.5); font-size: 9px;
            margin-top: 4px; letter-spacing: 3px;
        }
        .menu-bg {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(4px);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 20;
        }
        .title {
            font-size: 3.5rem; font-weight: 900; color: #fff;
            text-shadow: 2px 2px #ff00de, -2px -2px #00f2ff;
            letter-spacing: 4px;
        }
        .subtitle {
            color: #666; font-size: 0.75rem;
            letter-spacing: 6px; margin: 8px 0 30px;
        }
        .info-box {
            background: rgba(255,255,255,0.03);
            border: 1px solid #333; border-radius: 8px;
            padding: 22px 30px; max-width: 460px; width: 90%;
            text-align: left; color: #aaa; font-size: 12px;
            line-height: 1.9;
        }
        .info-box .key { color: #00f2ff; font-weight: 700; }
        .info-box p { font-size: 12px; }
        .info-section { margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.06); }
        .info-goal {
            text-align: center; font-size: 12px; color: #ffcc00;
            letter-spacing: 1px; margin-bottom: 6px;
        }
        .btn {
            pointer-events: auto;
            background: transparent;
            border: 2px solid #00f2ff; color: #00f2ff;
            padding: 12px 40px; font-size: 1rem;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase; letter-spacing: 3px;
            cursor: pointer; transition: all 0.2s;
            margin-top: 24px;
        }
        .btn:hover {
            background: #00f2ff; color: #000;
            box-shadow: 0 0 24px #00f2ff;
        }
        .btn-ai {
            border-color: #be00ff; color: #be00ff;
            font-size: 0.85rem; padding: 10px 24px; margin-top: 12px;
        }
        .btn-ai:hover {
            background: #be00ff; color: #fff; box-shadow: 0 0 20px #be00ff;
        }
        .game-over-title {
            font-size: 3rem; font-weight: 900; color: #ff2244;
            text-shadow: 0 0 20px rgba(255,0,50,0.6);
            letter-spacing: 2px;
        }
        .final-score { color: #fff; font-size: 1.2rem; margin: 8px 0; }
        .final-score span { color: #00f2ff; }
        .ai-box {
            margin-top: 12px; padding: 14px;
            border: 1px dashed #be00ff;
            background: rgba(20,0,30,0.8);
            max-width: 400px; width: 90%;
            text-align: left; display: none;
        }
        .ai-box .ai-rank { color: #be00ff; font-size: 11px; font-weight: 700; }
        .ai-box .ai-log { color: #ccc; font-size: 12px; font-style: italic; margin-top: 4px; }
        .scanline {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; z-index: 5;
            background: repeating-linear-gradient(
                0deg,
                transparent, transparent 2px,
                rgba(0,255,255,0.015) 2px, rgba(0,255,255,0.015) 4px
            );
        }
        /* â”€â”€ Achievement Summary (game over) â”€â”€ */
        .over-ach-wrap {
            display: flex; flex-wrap: wrap; gap: 6px;
            justify-content: center; margin-top: 6px;
        }
        .over-ach-item {
            background: rgba(255,204,0,0.08); border: 1px solid rgba(255,204,0,0.3);
            border-radius: 4px; padding: 4px 10px;
            font-size: 11px; color: #ffcc00;
            animation: achFadeIn 0.4s ease-out both;
        }
        .over-ach-item .ach-i { margin-right: 4px; }
        .over-ach-item .ach-d { color: #888; font-size: 9px; margin-left: 4px; }
        @keyframes achFadeIn { from { opacity:0; transform:translateY(8px); } to { opacity:1; transform:translateY(0); } }
        /* â”€â”€ Name Input â”€â”€ */
        .name-section {
            margin-top: 18px; display: flex; flex-direction: column;
            align-items: center; gap: 4px;
        }
        .name-label {
            font-size: 10px; color: #555; letter-spacing: 3px; text-transform: uppercase;
        }
        .name-input {
            background: rgba(0,242,255,0.05); border: 2px solid rgba(0,242,255,0.4);
            border-radius: 4px;
            color: #00f2ff; font-family: 'Orbitron', sans-serif;
            font-size: 16px; padding: 10px 16px; width: 240px;
            text-align: center; letter-spacing: 3px;
            outline: none; transition: all 0.2s;
        }
        .name-input::placeholder { color: rgba(0,242,255,0.2); letter-spacing: 2px; font-size: 13px; }
        .name-input:focus { border-color: #00f2ff; background: rgba(0,242,255,0.08); box-shadow: 0 0 16px rgba(0,242,255,0.2); }
        .name-hint {
            font-size: 9px; color: #555; margin-top: 2px;
            letter-spacing: 1px; height: 14px; transition: color 0.2s;
        }
        .btn-start {
            pointer-events: auto;
            background: rgba(0,242,255,0.1); border: 2px solid #00f2ff;
            color: #00f2ff; padding: 14px 50px; font-size: 1.1rem;
            font-family: 'Orbitron', sans-serif; font-weight: 700;
            text-transform: uppercase; letter-spacing: 4px;
            cursor: pointer; transition: all 0.25s;
            margin-top: 16px; border-radius: 4px;
        }
        .btn-start:hover {
            background: #00f2ff; color: #000;
            box-shadow: 0 0 30px rgba(0,242,255,0.5);
        }
        .btn-start.disabled {
            background: transparent; border-color: #222; color: #333;
            cursor: not-allowed; box-shadow: none;
        }
        .btn-start.disabled:hover { background: transparent; color: #333; box-shadow: none; }
        .btn-sub {
            pointer-events: auto;
            background: transparent; border: 1px solid #444; color: #666;
            padding: 7px 18px; font-size: 0.65rem;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px; cursor: pointer;
            transition: all 0.2s; border-radius: 3px;
        }
        .btn-sub:hover { border-color: #888; color: #ccc; }
        .btn-sub.disabled { border-color: #222; color: #2a2a2a; cursor: not-allowed; }
        .btn-sub.disabled:hover { border-color: #222; color: #2a2a2a; }
        /* â”€â”€ Leaderboard â”€â”€ */
        .leaderboard { margin-top: 14px; width: 320px; max-height: 200px; overflow-y: auto; }
        .lb-row {
            display: flex; justify-content: space-between;
            padding: 4px 8px; font-size: 11px; color: #aaa;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .lb-row:nth-child(1) { color: #ffcc00; }
        .lb-row:nth-child(2) { color: #c0c0c0; }
        .lb-row:nth-child(3) { color: #cd7f32; }
        .lb-rank { width: 30px; text-align: center; }
        .lb-name { flex: 1; text-align: left; margin: 0 8px; overflow: hidden; text-overflow: ellipsis; }
        .lb-score { width: 60px; text-align: right; color: #00f2ff; }
        .lb-time { width: 50px; text-align: right; color: #666; }
        /* â”€â”€ Achievement Panel â”€â”€ */
        .achieve-panel {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); backdrop-filter: blur(4px);
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; z-index: 25; pointer-events: auto;
        }
        .achieve-grid {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 10px; max-width: 500px; width: 90%; margin-top: 16px;
            max-height: 50vh; overflow-y: auto;
        }
        .ach-card {
            background: rgba(255,255,255,0.03); border: 1px solid #333;
            border-radius: 6px; padding: 10px; text-align: center;
        }
        .ach-card.unlocked { border-color: #ffcc00; }
        .ach-card .ach-icon { font-size: 20px; }
        .ach-card .ach-name { font-size: 10px; color: #ccc; margin-top: 4px; }
        .ach-card .ach-info { font-size: 9px; color: #666; margin-top: 2px; }
        .ach-card.locked .ach-icon { opacity: 0.2; }
        .ach-card.locked .ach-name { color: #444; }
        /* â”€â”€ Card Selection Overlay â”€â”€ */
        .card-overlay {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.82);
            backdrop-filter: blur(6px);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 30; pointer-events: auto;
        }
        .card-title {
            font-size: 1.4rem; font-weight: 700; color: #00f2ff;
            letter-spacing: 4px; margin-bottom: 8px;
            text-shadow: 0 0 12px rgba(0,242,255,0.5);
        }
        .card-subtitle {
            font-size: 0.7rem; color: #555; letter-spacing: 3px; margin-bottom: 24px;
        }
        .card-container { display: flex; gap: 18px; }
        .card-item {
            width: 160px; padding: 18px 14px;
            background: rgba(10,10,20,0.95);
            border: 2px solid #444; border-radius: 8px;
            cursor: pointer; transition: all 0.2s;
            text-align: center; position: relative;
        }
        .card-item:hover {
            transform: translateY(-6px);
            box-shadow: 0 8px 30px rgba(0,242,255,0.2);
        }
        .card-item.rarity-common { border-color: #aaa; }
        .card-item.rarity-common:hover { border-color: #fff; }
        .card-item.rarity-rare { border-color: #4488ff; }
        .card-item.rarity-rare:hover { border-color: #66aaff; box-shadow: 0 8px 30px rgba(68,136,255,0.3); }
        .card-item.rarity-epic { border-color: #aa44ff; }
        .card-item.rarity-epic:hover { border-color: #cc66ff; box-shadow: 0 8px 30px rgba(170,68,255,0.3); }
        .card-name {
            font-size: 0.85rem; font-weight: 700; color: #fff;
            margin-bottom: 8px; letter-spacing: 1px;
        }
        .card-desc {
            font-size: 0.65rem; color: #999; line-height: 1.6;
            font-family: sans-serif;
        }
        .card-rarity-tag {
            font-size: 0.55rem; letter-spacing: 2px;
            margin-top: 10px; padding: 2px 8px;
            border-radius: 3px; display: inline-block;
        }
        .card-rarity-tag.common { background: rgba(170,170,170,0.15); color: #aaa; }
        .card-rarity-tag.rare { background: rgba(68,136,255,0.15); color: #4488ff; }
        .card-rarity-tag.epic { background: rgba(170,68,255,0.15); color: #aa44ff; }
        .card-level {
            position: absolute; top: 6px; right: 8px;
            font-size: 0.6rem; color: #ffcc00;
        }
        .card-skip {
            pointer-events: auto; margin-top: 20px;
            background: transparent; border: 1px solid #555;
            color: #666; padding: 8px 28px; font-size: 0.7rem;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px; cursor: pointer; transition: all 0.2s;
        }
        .card-skip:hover { border-color: #888; color: #aaa; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="scanline"></div>

<div id="hud" class="ui-layer hidden">
    <div class="hud">
        <div class="hud-score">SCORE: <span id="scoreVal">0</span></div>
        <div class="hud-best">BEST: <span id="bestVal">0</span></div>
        <div class="hud-hp-wrap">
            <div class="hud-hp-bg"><div class="hud-hp-fill" id="hpBar"></div></div>
            <div class="hud-hp-label">SHIELD</div>
        </div>
    </div>
    <div class="energy-wrap">
        <div class="energy-bar-bg"><div class="energy-bar-fill" id="eBar"></div></div>
        <div class="energy-label">SONAR ENERGY</div>
    </div>
    <button id="btnPause" style="position:fixed;top:12px;right:12px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.15);color:#888;font-family:'Orbitron',sans-serif;font-size:14px;padding:6px 12px;cursor:pointer;border-radius:4px;z-index:90;pointer-events:auto;" onclick="togglePause()">â¸</button>
</div>

<div id="pauseOverlay" class="menu-bg hidden" style="z-index:95;overflow-y:auto;padding:30px 20px;display:none;flex-direction:column;align-items:center;">
    <div style="font-family:'Orbitron',sans-serif;font-size:20px;color:#00f2ff;letter-spacing:4px;margin-bottom:16px;">PAUSED</div>
    <div style="font-size:10px;color:#666;letter-spacing:2px;margin-bottom:10px;">â€” æ“ä½œ â€”</div>
    <div style="font-size:12px;color:#aaa;text-align:center;line-height:2;">
        <span style="color:#00f2ff;">WASD</span> ç§»åŠ¨ &nbsp; <span style="color:#00f2ff;">é¼ æ ‡</span> ç„å‡† &nbsp; <span style="color:#00f2ff;">å·¦é”®</span> å°„å‡» &nbsp; <span style="color:#00f2ff;">å³é”®</span> å£°çº³ &nbsp; <span style="color:#00f2ff;">ç©ºæ ¼</span> æš‚åœ
    </div>
    <div style="font-size:10px;color:#666;letter-spacing:2px;margin:14px 0 8px;">â€” æ•Œäººå›¾é‰´ â€”</div>
    <div id="pauseEnemyGuide" style="display:flex;flex-wrap:wrap;justify-content:center;gap:10px;max-width:500px;"></div>
    <div style="font-size:10px;color:#666;letter-spacing:2px;margin:14px 0 8px;">â€” Boss â€”</div>
    <div id="pauseBossGuide" style="display:flex;flex-wrap:wrap;justify-content:center;gap:10px;max-width:500px;"></div>
    <div style="font-size:10px;color:#666;letter-spacing:2px;margin:14px 0 8px;">â€” é“å…· â€”</div>
    <div style="display:flex;justify-content:center;gap:16px;flex-wrap:wrap;max-width:420px;">
        <div style="text-align:center;">
            <svg width="24" height="24" viewBox="0 0 24 24"><polygon points="12,1 23,12 12,23 1,12" fill="none" stroke="#ff66aa" stroke-width="1.5"/><text x="12" y="14" text-anchor="middle" font-size="8" font-weight="bold" fill="#ff66aa" font-family="monospace">+</text></svg>
            <div style="color:#ff66aa;font-size:9px;">å›è¡€</div>
        </div>
        <div style="text-align:center;">
            <svg width="24" height="24" viewBox="0 0 24 24"><polygon points="12,1 23,12 12,23 1,12" fill="none" stroke="#66ffcc" stroke-width="1.5"/><text x="12" y="14" text-anchor="middle" font-size="8" font-weight="bold" fill="#66ffcc" font-family="monospace">E</text></svg>
            <div style="color:#66ffcc;font-size:9px;">èƒ½é‡</div>
        </div>
        <div style="text-align:center;">
            <svg width="24" height="24" viewBox="0 0 24 24"><polygon points="12,1 23,12 12,23 1,12" fill="none" stroke="#66ccff" stroke-width="1.5"/><text x="12" y="14" text-anchor="middle" font-size="8" font-weight="bold" fill="#66ccff" font-family="monospace">S</text></svg>
            <div style="color:#66ccff;font-size:9px;">æŠ¤ç›¾</div>
        </div>
        <div style="text-align:center;">
            <svg width="24" height="24" viewBox="0 0 24 24"><polygon points="12,1 23,12 12,23 1,12" fill="none" stroke="#ffcc00" stroke-width="1.5"/><text x="12" y="14" text-anchor="middle" font-size="8" font-weight="bold" fill="#ffcc00" font-family="monospace">D</text></svg>
            <div style="color:#ffcc00;font-size:9px;">åŒå€åˆ†</div>
        </div>
        <div style="text-align:center;">
            <svg width="24" height="24" viewBox="0 0 24 24"><polygon points="7,1 17,1 23,7 23,17 17,23 7,23 1,17 1,7" fill="none" stroke="#ffaa00" stroke-width="1.5"/><text x="12" y="14.5" text-anchor="middle" font-size="9" font-weight="bold" fill="#ffaa00" font-family="monospace">C</text></svg>
            <div style="color:#ffaa00;font-size:9px;">èŠ¯ç‰‡ç®±</div>
            <div style="color:#997700;font-size:7px;">æŠ½å¡æå‡æŠ€èƒ½</div>
        </div>
    </div>
    <button class="btn" style="margin-top:18px;font-size:0.7rem;padding:8px 24px;" onclick="togglePause()">ç»§ç»­æ¸¸æˆ</button>
</div>

<div id="cardOverlay" class="card-overlay hidden">
    <div class="card-title">SYSTEM UPGRADE</div>
    <div class="card-subtitle">é€‰æ‹©ä¸€å¼ å¡ç‰Œå¼ºåŒ–</div>
    <div class="card-container" id="cardContainer"></div>
    <button class="card-skip" id="btnSkipCard">è·³ è¿‡</button>
</div>

<div id="menuStart" class="menu-bg">
    <div class="title">NEON ECHO</div>
    <div class="subtitle">åœ¨è¿·é›¾ä¸­ç”Ÿå­˜</div>

    <!-- æ ¸å¿ƒè¯´æ˜ -->
    <div class="info-box">
        <div style="font-size:12px; color:#aaa; text-align:center; line-height:2; letter-spacing:1px; padding-bottom:12px; margin-bottom:12px; border-bottom:1px solid rgba(255,255,255,0.08);">
            <span style="color:#00f2ff; font-weight:700;">WASD</span> ç§»åŠ¨ &nbsp;&nbsp;
            <span style="color:#00f2ff; font-weight:700;">é¼ æ ‡</span> ç„å‡† &nbsp;&nbsp;
            <span style="color:#00f2ff; font-weight:700;">å·¦é”®</span> å°„å‡» &nbsp;&nbsp;
            <span style="color:#00f2ff; font-weight:700;">å³é”®</span> å£°çº³ &nbsp;&nbsp;
            <span style="color:#00f2ff; font-weight:700;">ç©ºæ ¼</span> æš‚åœ
        </div>
        <p style="color:#aaa; font-size:12px; line-height:1.9;">ä½ åªèƒ½çœ‹åˆ°èº«è¾¹æè¿‘çš„åŒºåŸŸã€‚<span style="color:#00f2ff; font-weight:700;">å£°çº³</span>å¯æ¢æµ‹è¿œå¤„çš„æ•Œäººå’Œé“å…·ï¼Œä½†ä¼š<span style="color:#ffaa44; font-weight:700;">æš´éœ²ä½ çš„ä½ç½®</span>ã€‚å‡»æ€æ•Œäººè·å¾—ç§¯åˆ†å’Œèƒ½é‡ã€‚</p>
        <p style="color:#999; font-size:12px; margin-top:14px;">é“å…·ä»…åœ¨å£°çº³ç…§äº®åæ‰å¯è§å’Œæ‹¾å–ï¼š</p>
        <div style="display:flex; justify-content:center; gap:24px; flex-wrap:wrap; margin-top:10px;">
            <div style="text-align:center; line-height:1.5;">
                <svg width="32" height="32" viewBox="0 0 32 32"><polygon points="16,2 30,16 16,30 2,16" fill="none" stroke="#ff66aa" stroke-width="2"/><text x="16" y="18.5" text-anchor="middle" font-size="10" font-weight="bold" fill="#ff66aa" font-family="monospace">+</text></svg>
                <div style="color:#ff66aa; font-size:11px;">å›è¡€</div>
            </div>
            <div style="text-align:center; line-height:1.5;">
                <svg width="32" height="32" viewBox="0 0 32 32"><polygon points="16,2 30,16 16,30 2,16" fill="none" stroke="#66ffcc" stroke-width="2"/><text x="16" y="18.5" text-anchor="middle" font-size="10" font-weight="bold" fill="#66ffcc" font-family="monospace">E</text></svg>
                <div style="color:#66ffcc; font-size:11px;">èƒ½é‡</div>
            </div>
            <div style="text-align:center; line-height:1.5;">
                <svg width="32" height="32" viewBox="0 0 32 32"><polygon points="16,2 30,16 16,30 2,16" fill="none" stroke="#66ccff" stroke-width="2"/><text x="16" y="18.5" text-anchor="middle" font-size="10" font-weight="bold" fill="#66ccff" font-family="monospace">S</text></svg>
                <div style="color:#66ccff; font-size:11px;">æŠ¤ç›¾</div>
            </div>
            <div style="text-align:center; line-height:1.5;">
                <svg width="32" height="32" viewBox="0 0 32 32"><polygon points="16,2 30,16 16,30 2,16" fill="none" stroke="#ffcc00" stroke-width="2"/><text x="16" y="18.5" text-anchor="middle" font-size="10" font-weight="bold" fill="#ffcc00" font-family="monospace">D</text></svg>
                <div style="color:#ffcc00; font-size:11px;">åŒå€åˆ†</div>
            </div>
            <div style="text-align:center; line-height:1.5;">
                <svg width="32" height="32" viewBox="0 0 32 32"><polygon points="10,2 22,2 30,10 30,22 22,30 10,30 2,22 2,10" fill="none" stroke="#ffaa00" stroke-width="2"/><text x="16" y="19" text-anchor="middle" font-size="11" font-weight="bold" fill="#ffaa00" font-family="monospace">C</text></svg>
                <div style="color:#ffaa00; font-size:11px;">èŠ¯ç‰‡ç®±</div>
                <div style="color:#997700; font-size:8px;">é€‰å¡å‡çº§æŠ€èƒ½</div>
            </div>
        </div>
        <p style="color:#999; font-size:12px; margin-top:16px; text-align:left;">åœ°å½¢ä¼šé€æ­¥å˜åŒ–ï¼šå‡ºç°å¢™ä½“é®æŒ¡å£°çº³ï¼ŒåæœŸè¿˜æœ‰<span style="color:#ffaa44; font-weight:700;">è„†å¼±å¢™</span>å’Œ<span style="color:#66ccff; font-weight:700;">åå°„å¢™</span>ã€‚</p>
    </div>
    <div class="name-section">
        <div class="name-label">è¾“å…¥ä½ çš„ä»£å·</div>
        <div style="position:relative;width:240px;">
            <input type="text" class="name-input" id="playerNameInput" placeholder="AGENT-X" maxlength="12" autocomplete="off" style="width:100%;box-sizing:border-box;">
            <div id="nameDropdown" style="display:none;position:absolute;top:100%;left:0;right:0;background:#0a0a0a;border:1px solid rgba(0,242,255,0.3);border-top:none;border-radius:0 0 4px 4px;max-height:120px;overflow-y:auto;z-index:100;"></div>
        </div>
        <div class="name-hint" id="nameHint">è¾“å…¥ä»£å·ä»¥è§£é”</div>
    </div>
    <button class="btn-start disabled" id="btnStart">â–¶ è¿›å…¥è¿·é›¾</button>
    <div style="display:flex; gap:14px; margin-top:14px;">
        <button class="btn-sub disabled" id="btnAchievements">â˜† æˆå°±</button>
        <button class="btn-sub" id="btnLeaderboard">âŠ æ’è¡Œæ¦œ</button>
    </div>
</div>

<div id="menuOver" class="menu-bg hidden">
    <div class="game-over-title">SIGNAL LOST</div>
    <div class="final-score">æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span> &nbsp; å­˜æ´»: <span id="finalTime">0</span>s</div>
    <div class="ai-box" id="aiBox" style="display:block;">
        <div class="ai-rank" id="aiRank">ANALYZING...</div>
        <div class="ai-log" id="aiLog">æ•°æ®æ¢å¤ä¸­...</div>
    </div>
    <div id="overAchievements" style="margin-top:8px; max-width:400px; width:90%;"></div>
    <div class="leaderboard" id="overLeaderboard"></div>
    <button class="btn" id="btnRestart">é‡æ–°è¿æ¥</button>
</div>

<div id="achievePanel" class="achieve-panel hidden">
    <div style="font-size:1.2rem; font-weight:700; color:#ffcc00; letter-spacing:3px;">æˆå°±</div>
    <div id="achievePlayerName" style="font-size:0.7rem; color:#888; margin-top:2px;"></div>
    <div style="font-size:0.6rem; color:#555; margin-top:2px;" id="achieveProgress"></div>
    <div class="achieve-grid" id="achieveGrid"></div>
    <button class="btn" style="font-size:0.7rem; padding:8px 20px;" id="btnCloseAchieve">è¿”å›</button>
</div>

<div id="leaderPanel" class="achieve-panel hidden">
    <div style="font-size:1.2rem; font-weight:700; color:#00f2ff; letter-spacing:3px;">æ’è¡Œæ¦œ</div>
    <div class="leaderboard" id="fullLeaderboard" style="max-height:60vh;"></div>
    <button class="btn" style="font-size:0.7rem; padding:8px 20px;" id="btnCloseLeader">è¿”å›</button>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NEON ECHO v4.0 â€” Full Feature
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SOUND ENGINE (Web Audio API â€” procedural synth, no files)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }

let lastShootSfx = 0;
const SFX = {
    shoot() {
        ensureAudio();
        // Throttle: max 8 shoot sounds/sec to avoid audio node GC stutter
        const now = audioCtx.currentTime;
        if (now - lastShootSfx < 0.12) return;
        lastShootSfx = now;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'square'; o.frequency.setValueAtTime(800, now);
        o.frequency.exponentialRampToValueAtTime(200, now + 0.06);
        g.gain.setValueAtTime(0.08, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(now + 0.06);
    },
    sonar() {
        ensureAudio();
        const t = audioCtx.currentTime;
        // Layer 1: clean ping â€” short sine blip downward
        const o1 = audioCtx.createOscillator();
        const g1 = audioCtx.createGain();
        o1.type = 'sine';
        o1.frequency.setValueAtTime(880, t);
        o1.frequency.exponentialRampToValueAtTime(440, t + 0.08);
        o1.frequency.exponentialRampToValueAtTime(220, t + 0.25);
        g1.gain.setValueAtTime(0.09, t);
        g1.gain.linearRampToValueAtTime(0.06, t + 0.05);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        o1.connect(g1); g1.connect(audioCtx.destination);
        o1.start(t); o1.stop(t + 0.3);
        // Layer 2: soft echo tail â€” delayed quieter ping
        const o2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        o2.type = 'sine';
        o2.frequency.setValueAtTime(660, t + 0.08);
        o2.frequency.exponentialRampToValueAtTime(165, t + 0.4);
        g2.gain.setValueAtTime(0.0001, t);
        g2.gain.linearRampToValueAtTime(0.04, t + 0.1);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.45);
        o2.connect(g2); g2.connect(audioCtx.destination);
        o2.start(t + 0.08); o2.stop(t + 0.45);
    },
    _lastEnemyHit: 0,
    enemyHit() {
        ensureAudio();
        const now = audioCtx.currentTime;
        if (now - this._lastEnemyHit < 0.06) return;
        this._lastEnemyHit = now;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'triangle'; o.frequency.setValueAtTime(1200, now);
        o.frequency.exponentialRampToValueAtTime(400, now + 0.04);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(now + 0.05);
    },
    _hitBuf: null,
    _lastHit: 0,
    hit() {
        ensureAudio();
        const now = audioCtx.currentTime;
        if (now - this._lastHit < 0.08) return;
        this._lastHit = now;
        // Reuse pre-generated noise buffer
        if (!this._hitBuf) {
            const bufSize = audioCtx.sampleRate * 0.05;
            this._hitBuf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
            const d = this._hitBuf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / bufSize);
        }
        const src = audioCtx.createBufferSource();
        const g = audioCtx.createGain();
        src.buffer = this._hitBuf; g.gain.setValueAtTime(0.1, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
        src.connect(g); g.connect(audioCtx.destination);
        src.start();
    },
    explosion() {
        ensureAudio();
        const bufSize = audioCtx.sampleRate * 0.25;
        const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufSize, 2);
        const src = audioCtx.createBufferSource();
        const g = audioCtx.createGain();
        src.buffer = buf; g.gain.setValueAtTime(0.15, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
        src.connect(g); g.connect(audioCtx.destination);
        src.start();
    },
    pickup() {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine'; o.frequency.setValueAtTime(600, audioCtx.currentTime);
        o.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
        g.gain.setValueAtTime(0.08, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.12);
    },
    cardSelect() {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'triangle';
        o.frequency.setValueAtTime(400, audioCtx.currentTime);
        o.frequency.setValueAtTime(600, audioCtx.currentTime + 0.06);
        o.frequency.setValueAtTime(900, audioCtx.currentTime + 0.12);
        g.gain.setValueAtTime(0.07, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.18);
    },
    bossWarn() {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sawtooth'; o.frequency.setValueAtTime(120, audioCtx.currentTime);
        o.frequency.setValueAtTime(180, audioCtx.currentTime + 0.2);
        o.frequency.setValueAtTime(120, audioCtx.currentTime + 0.4);
        g.gain.setValueAtTime(0.1, audioCtx.currentTime);
        g.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.2);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.5);
    },
    bossDead() {
        ensureAudio();
        for (let i = 0; i < 3; i++) {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = 'sine';
            o.frequency.setValueAtTime(400 + i * 200, audioCtx.currentTime + i * 0.12);
            g.gain.setValueAtTime(0.08, audioCtx.currentTime + i * 0.12);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + i * 0.12 + 0.2);
            o.connect(g); g.connect(audioCtx.destination);
            o.start(audioCtx.currentTime + i * 0.12);
            o.stop(audioCtx.currentTime + i * 0.12 + 0.2);
        }
    },
    playerHit() {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sawtooth'; o.frequency.setValueAtTime(200, audioCtx.currentTime);
        o.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 0.15);
        g.gain.setValueAtTime(0.12, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.15);
    },
    shieldBreak() {
        ensureAudio();
        const bufSize = audioCtx.sampleRate * 0.2;
        const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < bufSize; i++) {
            const t = i / audioCtx.sampleRate;
            d[i] = Math.sin(t * 800 * Math.PI * 2) * 0.3 * Math.pow(1 - i / bufSize, 1.5)
                 + (Math.random() * 2 - 1) * 0.2 * Math.pow(1 - i / bufSize, 2);
        }
        const src = audioCtx.createBufferSource();
        const g = audioCtx.createGain();
        src.buffer = buf; g.gain.setValueAtTime(0.12, audioCtx.currentTime);
        src.connect(g); g.connect(audioCtx.destination);
        src.start();
    },
    death() {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sawtooth'; o.frequency.setValueAtTime(300, audioCtx.currentTime);
        o.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.8);
        g.gain.setValueAtTime(0.15, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.8);
    },
    achieve() {
        ensureAudio();
        const notes = [523, 659, 784, 1047]; // C5 E5 G5 C6
        notes.forEach((f, i) => {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = 'sine'; o.frequency.value = f;
            g.gain.setValueAtTime(0.06, audioCtx.currentTime + i * 0.08);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + i * 0.08 + 0.15);
            o.connect(g); g.connect(audioCtx.destination);
            o.start(audioCtx.currentTime + i * 0.08);
            o.stop(audioCtx.currentTime + i * 0.08 + 0.15);
        });
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BACKGROUND MUSIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let bgm = null;
let bgmStopTimeout = null;
function initBGM() {
    if (bgm) return;
    bgm = new Audio('Perpetual Neon-Hunt.mp3');
    bgm.loop = true;
    bgm.volume = 0.3;
}
function playBGM() {
    initBGM();
    bgm.volume = 0.3;
    if (bgm.paused) bgm.play().catch(() => {});
}
function stopBGM() {
    if (bgm && !bgm.paused) {
        bgm.pause();
        bgm.currentTime = 0;
    }
}
function fadeBGM(targetVol, duration) {
    if (!bgm) return;
    const startVol = bgm.volume;
    const startTime = performance.now();
    function step() {
        const elapsed = (performance.now() - startTime) / (duration * 1000);
        if (elapsed >= 1) { bgm.volume = targetVol; return; }
        bgm.volume = startVol + (targetVol - startVol) * elapsed;
        requestAnimationFrame(step);
    }
    step();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ACHIEVEMENT SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ACHIEVEMENTS = [
    { id: 'first_kill',    icon: 'ğŸ’€', name: 'åˆæ¬¡å‡»æ€',     desc: 'æ¶ˆç­ç¬¬ä¸€ä¸ªæ•Œäºº', check: s => s.kills >= 1 },
    { id: 'kill_50',       icon: 'ğŸ”¥', name: 'æˆ˜æ–—æœºå™¨',     desc: 'å•å±€å‡»æ€50ä¸ªæ•Œäºº', check: s => s.kills >= 50 },
    { id: 'kill_200',      icon: 'â˜ ï¸', name: 'æ­»ç¥',         desc: 'å•å±€å‡»æ€200ä¸ªæ•Œäºº', check: s => s.kills >= 200 },
    { id: 'survive_60',    icon: 'â±ï¸', name: 'ä¸€åˆ†é’Ÿ',       desc: 'å­˜æ´»60ç§’', check: s => s.time >= 60 },
    { id: 'survive_180',   icon: 'â°', name: 'ä¸‰åˆ†é’Ÿ',       desc: 'å­˜æ´»180ç§’', check: s => s.time >= 180 },
    { id: 'survive_300',   icon: 'ğŸ†', name: 'äº”åˆ†é’Ÿä¼ å¥‡',   desc: 'å­˜æ´»300ç§’', check: s => s.time >= 300 },
    { id: 'score_500',     icon: 'â­', name: 'æ–°æ˜Ÿ',         desc: 'å¾—åˆ†è¾¾åˆ°500', check: s => s.score >= 500 },
    { id: 'score_2000',    icon: 'ğŸŒŸ', name: 'è¶…æ–°æ˜Ÿ',       desc: 'å¾—åˆ†è¾¾åˆ°2000', check: s => s.score >= 2000 },
    { id: 'score_5000',    icon: 'ğŸ’«', name: 'è„‰å†²æ˜Ÿ',       desc: 'å¾—åˆ†è¾¾åˆ°5000', check: s => s.score >= 5000 },
    { id: 'boss_kill',     icon: 'ğŸ‘‘', name: 'BossçŒæ‰‹',     desc: 'å‡»æ€ç¬¬ä¸€ä¸ªBoss', check: s => s.bossKills >= 1 },
    { id: 'boss_3',        icon: 'ğŸ…', name: 'ä¸‰å† ç‹',       desc: 'å•å±€å‡»æ€3ä¸ªBoss', check: s => s.bossKills >= 3 },
    { id: 'no_damage_30',  icon: 'ğŸ›¡ï¸', name: 'æ— ä¼¤30ç§’',     desc: 'è¿ç»­30ç§’ä¸å—ä¼¤', check: s => s.maxNoDmgTime >= 30 },
    { id: 'card_5',        icon: 'ğŸƒ', name: 'æ”¶è—å®¶',       desc: 'è·å¾—5å¼ ä¸åŒå¡ç‰Œ', check: s => s.uniqueCards >= 5 },
    { id: 'card_max',      icon: 'ğŸ’', name: 'æ»¡çº§å¤§å¸ˆ',     desc: 'å°†ä»»æ„å¡ç‰Œå‡è‡³Lv.5', check: s => s.maxCardLv >= 5 },
    { id: 'hive_clear',    icon: 'ğŸ', name: 'æ¸…å·¢è€…',       desc: 'å‡»æ€ä¸€ä¸ªèœ‚å·¢', check: s => s.hiveKills >= 1 },
    { id: 'phantom_kill',  icon: 'ğŸ‘»', name: 'çŒé­‚è€…',       desc: 'å‡»æ€3ä¸ªå¹½çµ', check: s => s.phantomKills >= 3 },
    { id: 'wall_break',    icon: 'ğŸ’¥', name: 'ç ´å£è€…',       desc: 'æ‘§æ¯ä¸€é¢è„†å¼±å¢™', check: s => s.wallsBroken >= 1 },
    { id: 'shield_use',    icon: 'âš¡', name: 'ç›¾å',         desc: 'ä½¿ç”¨æŠ¤ç›¾çˆ†ç‚¸å‡»æ€æ•Œäºº', check: s => s.shieldKills >= 1 },
    // â”€â”€ Progression achievements â”€â”€
    { id: 'survive_600',   icon: 'ğŸ–ï¸', name: 'ååˆ†é’Ÿä¼ è¯´',   desc: 'å­˜æ´»600ç§’ï¼ˆå®Œæ•´é€šå…³ï¼‰', check: s => s.time >= 600 },
    { id: 'score_10000',   icon: 'ğŸ‘‘', name: 'æš—åŸŸä¹‹ç‹',     desc: 'å¾—åˆ†è¾¾åˆ°10000', check: s => s.score >= 10000 },
    { id: 'kill_500',      icon: 'ğŸ’€', name: 'ç­ç»è€…',       desc: 'å•å±€å‡»æ€500ä¸ªæ•Œäºº', check: s => s.kills >= 500 },
    { id: 'boss_5',        icon: 'ğŸ†', name: 'å…¨Bossé€šå…³',   desc: 'å•å±€å‡»æ€5ä¸ªBoss', check: s => s.bossKills >= 5 },
    { id: 'all_boss_types',icon: 'ğŸŒŸ', name: 'ç»ˆæçŒæ‰‹',     desc: 'å‡»æ€å…¨éƒ¨5ç§Boss', check: s => s.bossTypesKilled.size >= 5 },
    // â”€â”€ Challenge achievements â”€â”€
    { id: 'no_damage_60',  icon: 'âœ¨', name: 'é‡‘èº«',         desc: 'è¿ç»­60ç§’ä¸å—ä¼¤', check: s => s.maxNoDmgTime >= 60 },
    { id: 'no_sonar_120',  icon: 'ğŸŒ‘', name: 'ç›²è€…ä¹‹é“',     desc: 'è¿ç»­120ç§’ä¸ä½¿ç”¨å£°çº³', check: s => s.maxNoSonarTime >= 120 },
    { id: 'tier3_survive', icon: 'ğŸ”´', name: 'ç›´é¢ç‹‚æš´',     desc: 'å­˜æ´»åˆ°æ•Œäººç‹‚æš´é˜¶æ®µ', check: s => s.tierReached >= 3 },
    // â”€â”€ Mastery achievements â”€â”€
    { id: 'drainer_kill',  icon: 'ğŸ”‹', name: 'èƒ½é‡å®ˆæŠ¤è€…',   desc: 'å‡»æ€ä¸€ä¸ªå¸èƒ½è€…', check: s => s.drainerKills >= 1 },
    { id: 'card_10',       icon: 'ğŸ“š', name: 'å…¨èƒ½é€‰æ‰‹',     desc: 'è·å¾—10å¼ ä¸åŒå¡ç‰Œ', check: s => s.uniqueCards >= 10 },
    { id: 'dual_max',      icon: 'ğŸ’', name: 'åŒæ ¸å¤§å¸ˆ',     desc: 'åŒæ—¶æ‹¥æœ‰2å¼ Lv.5å¡ç‰Œ', check: s => s.cardsMaxed >= 2 },
    { id: 'reflect_kill',  icon: 'ğŸª', name: 'ä»¥å½¼ä¹‹é“',     desc: 'ç”¨åå¼¹å­å¼¹å‡»æ€æ•Œäºº', check: s => s.reflectKills >= 1 },
];

let unlockedAchievements = []; // loaded per-player on name input/startGame
// Session stats for achievement checking
let sessionStats = {};
function resetSessionStats() {
    sessionStats = {
        kills: 0, bossKills: 0, score: 0, time: 0,
        maxNoDmgTime: 0, noDmgTimer: 0,
        uniqueCards: 0, maxCardLv: 0,
        hiveKills: 0, phantomKills: 0, drainerKills: 0,
        wallsBroken: 0, shieldKills: 0,
        noSonarTimer: 0, maxNoSonarTime: 0,
        bossTypesKilled: new Set(),
        tierReached: 0,
        reflectKills: 0,
        cardsMaxed: 0,       // number of cards at Lv.5
    };
}
resetSessionStats();

function checkAchievements() {
    sessionStats.time = gameTime;
    sessionStats.score = score;
    if (player) {
        sessionStats.uniqueCards = player.cards.size;
        let maxLv = 0, maxedCount = 0;
        for (const lv of player.cards.values()) {
            maxLv = Math.max(maxLv, lv);
            if (lv >= 5) maxedCount++;
        }
        sessionStats.maxCardLv = maxLv;
        sessionStats.cardsMaxed = maxedCount;
    }
    for (const ach of ACHIEVEMENTS) {
        if (unlockedAchievements.includes(ach.id)) continue;
        if (ach.check(sessionStats)) {
            unlockedAchievements.push(ach.id);
            sessionNewAchievements.push(ach);
            localStorage.setItem('neonEchoAch_' + currentPlayerName, JSON.stringify(unlockedAchievements));
        }
    }
}
// Collected during gameplay, shown at game over
let sessionNewAchievements = [];

function renderAchievePanel() {
    document.getElementById('achievePlayerName').textContent = 'ä»£å·: ' + currentPlayerName;
    const count = unlockedAchievements.length;
    document.getElementById('achieveProgress').textContent = count + ' / ' + ACHIEVEMENTS.length + ' å·²è§£é”';
    const grid = document.getElementById('achieveGrid');
    grid.innerHTML = '';
    for (const ach of ACHIEVEMENTS) {
        const unlocked = unlockedAchievements.includes(ach.id);
        const card = document.createElement('div');
        card.className = 'ach-card ' + (unlocked ? 'unlocked' : 'locked');
        card.innerHTML = '<div class="ach-icon">' + ach.icon + '</div><div class="ach-name">' + ach.name + '</div><div class="ach-info">' + ach.desc + '</div>';
        grid.appendChild(card);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LEADERBOARD (localStorage)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let leaderboard = JSON.parse(localStorage.getItem('neonEchoLeaderboard') || '[]');
let currentPlayerName = localStorage.getItem('neonEchoPlayerName') || '';

function addToLeaderboard(name, sc, time) {
    if (!name) name = 'UNKNOWN';
    const existing = leaderboard.find(e => e.name === name);
    if (existing) {
        existing.runs = (existing.runs || 1) + 1;
        if (sc > existing.score) {
            existing.score = sc;
            existing.time = Math.floor(time);
            existing.date = Date.now();
            existing.isNew = true; // flag for highlight
        } else {
            existing.isNew = false;
        }
    } else {
        leaderboard.push({ name: name, score: sc, time: Math.floor(time), date: Date.now(), runs: 1, isNew: true });
    }
    leaderboard.sort((a, b) => b.score - a.score);
    if (leaderboard.length > 30) leaderboard = leaderboard.slice(0, 30); // keep top 30
    localStorage.setItem('neonEchoLeaderboard', JSON.stringify(leaderboard));
}

function renderLeaderboard(containerId, highlightName) {
    const el = document.getElementById(containerId);
    el.innerHTML = '';
    if (leaderboard.length === 0) {
        el.innerHTML = '<div style="color:#555;font-size:11px;text-align:center;padding:12px;">æš‚æ— è®°å½•</div>';
        return;
    }
    leaderboard.forEach((entry, i) => {
        const row = document.createElement('div');
        row.className = 'lb-row';
        if (highlightName && entry.name === highlightName) row.style.background = 'rgba(0,242,255,0.08)';
        const runsText = (entry.runs && entry.runs > 1) ? '<span style="color:#555;font-size:9px;margin-left:4px;">x' + entry.runs + '</span>' : '';
        row.innerHTML = '<span class="lb-rank">' + (i + 1) + '</span>'
            + '<span class="lb-name">' + entry.name + runsText + '</span>'
            + '<span class="lb-score">' + entry.score + '</span>'
            + '<span class="lb-time">' + entry.time + 's</span>';
        el.appendChild(row);
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BLACK BOX SETTLEMENT (programmatic)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function analyzeBlackBoxLocal() {
    const t = Math.floor(gameTime);
    const s = score;
    const k = sessionStats.kills;
    const bk = sessionStats.bossKills;
    const cards = player ? player.cards.size : 0;
    const noDmg = sessionStats.maxNoDmgTime;

    // Determine rank title
    let rank, log;
    if (t < 15) {
        rank = 'ä¿¡å·æ®‹ç‰‡';
        log = 'æ¢æµ‹å™¨åœ¨å¯åŠ¨åä¸ä¹…ä¾¿å å…¥äº†æ°¸æ’çš„é™é»˜ã€‚è¿è¿·é›¾éƒ½æ¥ä¸åŠè®°ä½å®ƒçš„å­˜åœ¨ã€‚';
    } else if (t < 40) {
        rank = 'å¾®å¼±å›å£°';
        log = 'çŸ­æš‚çš„ä¿¡å·è„‰å†²åˆ’è¿‡æ•°æ®æµï¼Œéšåè¢«å™ªéŸ³æ·¹æ²¡ã€‚' + (k > 0 ? 'å‡»æ¯äº†' + k + 'ä¸ªå¨èƒã€‚' : 'æœªç•™ä¸‹æˆ˜æ–—è®°å½•ã€‚');
    } else if (t < 90) {
        rank = 'è¿·é›¾è¡Œè€…';
        log = 'åœ¨ç”µç£è¿·é›¾ä¸­æŒ£æ‰å‰è¡Œ' + t + 'ç§’ã€‚' + (k > 10 ? 'å±•ç°å‡ºäº†ä¸€å®šçš„æˆ˜æ–—æœ¬èƒ½ï¼Œ' : '') + 'æœ€ç»ˆè¢«é»‘æš—åå™¬ã€‚å¾—åˆ†' + s + 'ã€‚';
    } else if (t < 150) {
        rank = 'å›å£°çŒäºº';
        log = 'å­˜æ´»' + t + 'ç§’ï¼Œå‡»æ¯' + k + 'ä¸ªç›®æ ‡ã€‚' + (bk > 0 ? 'æˆåŠŸå‡»æºƒ' + bk + 'ä¸ªé«˜çº§å¨èƒã€‚' : 'æœªèƒ½çªç ´Bossé˜²çº¿ã€‚') + (cards > 3 ? 'æ„å»ºäº†æœ‰æ•ˆçš„æˆ˜æœ¯ç»„åˆã€‚' : '');
    } else if (t < 240) {
        rank = 'è„‰å†²æŒ‡æŒ¥å®˜';
        log = 'åœ¨' + t + 'ç§’çš„æ¼«é•¿æˆ˜æ–—ä¸­å±•ç°å‡ºå“è¶Šçš„æˆ˜æœ¯æ„è¯†ã€‚' + k + 'æ¬¡ç²¾å‡†æ‰“å‡»ï¼Œ' + (bk > 1 ? bk + 'ä¸ªBossé™¨è½ã€‚' : '') + 'å£°çº³ä¸ç«åŠ›çš„äº¤ç»‡è°±å†™äº†å£®çƒˆçš„æˆ˜æ­Œã€‚';
    } else if (t < 360) {
        rank = 'éœ“è™¹å¹½çµ';
        log = t + 'ç§’â€”â€”è¿·é›¾ä¸­çš„ä¼ è¯´ã€‚' + k + 'ä¸ªç›®æ ‡æ¹®ç­ï¼Œ' + bk + 'ä¸ªBosså½’é›¶ã€‚' + (noDmg > 30 ? 'æ›¾æœ‰' + Math.floor(noDmg) + 'ç§’å®Œç¾é—ªé¿ã€‚' : '') + 'å¾—åˆ†' + s + 'ï¼Œå€¼å¾—é“­è®°ã€‚';
    } else {
        rank = 'è™šç©ºè¡Œè€…';
        log = 'è¶…è¶Šäº†ä¸€åˆ‡é¢„æœŸã€‚' + t + 'ç§’çš„å­˜æ´»è®°å½•ï¼Œ' + k + 'æ¬¡æ­¼ç­ï¼Œ' + bk + 'ä¸ªBossã€‚' + (cards >= 8 ? 'å®Œæ•´çš„æˆ˜æœ¯çŸ©é˜µå·²æ„å»ºã€‚' : '') + 'ä½ å°±æ˜¯è¿·é›¾æœ¬èº«ã€‚å¾—åˆ†' + s + 'ã€‚';
    }

    // Achievement bonuses in log
    const newAch = [];
    for (const ach of ACHIEVEMENTS) {
        if (ach.check(sessionStats) && !unlockedAchievements.includes(ach.id)) {
            // Already handled by checkAchievements, but note for log
        }
    }
    // Count session achievements
    const sessionAch = ACHIEVEMENTS.filter(a => a.check(sessionStats));
    if (sessionAch.length > 0) {
        log += ' [æœ¬å±€è¾¾æˆ' + sessionAch.length + 'é¡¹æˆå°±]';
    }

    $aiRank.textContent = rank.toUpperCase();
    $aiLog.textContent = '"' + log + '"';
}

let W, H;
function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
addEventListener('resize', resize); resize();

const rand = (a, b) => Math.random() * (b - a) + a;
const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const lerp = (a, b, t) => a + (b - a) * t;

const keys = {};
const mouse = { x: 0, y: 0, left: false, right: false };
addEventListener('keydown', e => {
    // Don't intercept typing in input fields
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
    keys[e.code] = true; e.preventDefault();
    // Space to toggle pause
    if (e.code === 'Space' && playing) { togglePause(); }
    // Escape to return to main menu
    if (e.code === 'Escape') { returnToMenu(); }
});
addEventListener('keyup', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
    keys[e.code] = false;
});
addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
addEventListener('mousedown', e => {
    if (e.button === 0) mouse.left = true;
    if (e.button === 2) mouse.right = true;
});
addEventListener('mouseup', e => {
    if (e.button === 0) mouse.left = false;
    if (e.button === 2) mouse.right = false;
});
addEventListener('contextmenu', e => e.preventDefault());

const $hud = document.getElementById('hud');
const $scoreVal = document.getElementById('scoreVal');
const $bestVal = document.getElementById('bestVal');
const $hpBar = document.getElementById('hpBar');
const $eBar = document.getElementById('eBar');
const $menuStart = document.getElementById('menuStart');
const $menuOver = document.getElementById('menuOver');
const $finalScore = document.getElementById('finalScore');
const $aiBox = document.getElementById('aiBox');
const $aiRank = document.getElementById('aiRank');
const $aiLog = document.getElementById('aiLog');

// â”€â”€ Name input â†’ enable/disable buttons â”€â”€
const $nameInput = document.getElementById('playerNameInput');
const $btnStart = document.getElementById('btnStart');
const $btnAch = document.getElementById('btnAchievements');
const $nameHint = document.getElementById('nameHint');

// All known player names (stored globally)
let knownPlayers = JSON.parse(localStorage.getItem('neonEchoPlayers') || '[]');

function populateNameHistory() {
    const dd = document.getElementById('nameDropdown');
    dd.innerHTML = '';
    for (const name of knownPlayers) {
        const item = document.createElement('div');
        item.textContent = name;
        item.style.cssText = 'padding:8px 16px;color:#00f2ff;font-family:Orbitron,sans-serif;font-size:13px;letter-spacing:2px;cursor:pointer;text-align:center;';
        item.onmouseenter = () => item.style.background = 'rgba(0,242,255,0.1)';
        item.onmouseleave = () => item.style.background = 'transparent';
        item.onclick = () => {
            $nameInput.value = name;
            dd.style.display = 'none';
            updateNameState();
        };
        dd.appendChild(item);
    }
}
populateNameHistory();
// Show/hide custom dropdown
const $nameDropdown = document.getElementById('nameDropdown');
$nameInput.addEventListener('focus', () => {
    if (knownPlayers.length > 0) $nameDropdown.style.display = 'block';
});
$nameInput.addEventListener('blur', () => {
    setTimeout(() => { $nameDropdown.style.display = 'none'; }, 200);
});

// Flag so we don't use stale pointer-events
let nameValid = false;

function updateNameState() {
    const name = $nameInput.value.trim();
    nameValid = name.length > 0;
    if (nameValid) {
        $btnStart.classList.remove('disabled');
        $btnStart.style.pointerEvents = 'auto';
        $btnAch.classList.remove('disabled');
        $btnAch.style.pointerEvents = 'auto';
        currentPlayerName = name;
        // Load this player's data
        unlockedAchievements = JSON.parse(localStorage.getItem('neonEchoAch_' + name) || '[]');
        best = parseInt(localStorage.getItem('neonEchoBest_' + name)) || 0;
        $bestVal.textContent = best || 'â€”';
        const isReturning = knownPlayers.includes(name);
        if (isReturning) {
            const achCount = unlockedAchievements.length;
            $nameHint.textContent = 'æ¬¢è¿å›æ¥ï¼Œ' + name + (achCount > 0 ? ' â€” ' + achCount + 'é¡¹æˆå°±' : '');
            $nameHint.style.color = '#00f2ff';
        } else {
            $nameHint.textContent = 'æ–°ä»£å·ï¼Œå‡†å¤‡å°±ç»ª';
            $nameHint.style.color = '#66ff88';
        }
    } else {
        $btnStart.classList.add('disabled');
        $btnStart.style.pointerEvents = 'none';
        $btnAch.classList.add('disabled');
        $btnAch.style.pointerEvents = 'none';
        $nameHint.textContent = 'è¾“å…¥ä»£å·ä»¥è§£é”';
        $nameHint.style.color = '#555';
    }
}

$nameInput.addEventListener('input', updateNameState);
$nameInput.addEventListener('change', updateNameState);
// Also handle Enter key to start game
$nameInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && nameValid) { e.preventDefault(); startGame(); }
});

// Do NOT pre-fill: start fresh each page load (user picks from datalist)
$nameInput.value = '';
currentPlayerName = '';
updateNameState();

$btnStart.onclick = () => {
    if (!nameValid) return;
    startGame();
};
document.getElementById('btnRestart').onclick = startGame;
$btnAch.onclick = () => {
    if (!nameValid) return;
    renderAchievePanel();
    document.getElementById('achievePanel').classList.remove('hidden');
};
document.getElementById('btnCloseAchieve').onclick = () => {
    document.getElementById('achievePanel').classList.add('hidden');
};
document.getElementById('btnLeaderboard').onclick = () => {
    renderLeaderboard('fullLeaderboard');
    document.getElementById('leaderPanel').classList.remove('hidden');
};
document.getElementById('btnCloseLeader').onclick = () => {
    document.getElementById('leaderPanel').classList.add('hidden');
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let playing = false;
let score = 0;
let best = 0; // loaded per-player
let gameTime = 0;
let frameCount = 0;
let dt = 1/60;
let lastTime = 0;
let shakeTimer = 0;
let damageFlash = 0;
let pickupFlashColor = '';
let pickupFlashTimer = 0;
let playerNoiseRadius = 0;
let playerNoiseX = 0, playerNoiseY = 0;
let player, pulses, bullets, enemies, particles, energyOrbs, supplyCrates, pickupTexts;
let walls = [];
let specialWalls = []; // fragile + reflect walls only (for optimized collision)
let cardSelectActive = false;
let cardCrateTimer = 0;
let sonarSlowFactor = 1; // updated each frame: speed multiplier for sonar-marked enemies
let cardCrates = [];
let achieveCheckTimer = 0;

// â”€â”€ Card Definitions (12 cards, max Lv.5, diminishing returns) â”€â”€
// Design philosophy:
//   - æ­¦å™¨æµ vs å£°çº³æµ vs ç”Ÿå­˜æµ ä¸‰æ¡è·¯çº¿
//   - æ¯å¼ å¡ Lv.1 å·²ç»æœ‰æ˜¾è‘—æ•ˆæœ, Lv.5 éå¸¸å¼ºä½†ä¸ç ´åæ¸¸æˆ
//   - èƒ½é‡ç›¸å…³å¡ç‰Œå¤šä¸”å¼ºï¼Œä¿è¯åæœŸä¸ç¼ºèƒ½é‡
const CARD_DEFS = [
    // â”€â”€ WEAPON (3) â”€â”€
    { id: 'scatter',      name: 'æ•£å°„æ¨¡å—', desc: 'å°„å‡»å˜ä¸ºæ‰‡å½¢å¼¹å¹•', rarity: 'rare',
      upgrades: ['3å‘å¼¹å¹•', '5å‘å¼¹å¹•', '7å‘å¼¹å¹•', '7å‘+10%ä¼¤å®³', '7å‘+20%ä¼¤å®³'] },
    { id: 'pierce',       name: 'ç©¿é€å¼¹å¤´', desc: 'å­å¼¹ç©¿é€æ•Œäººç»§ç»­é£è¡Œ', rarity: 'common',
      upgrades: ['ç©¿é€1ä¸ª', 'ç©¿é€2ä¸ª', 'ç©¿é€2ä¸ª+10%ä¼¤å®³', 'ç©¿é€3ä¸ª+10%ä¼¤å®³', 'ç©¿é€3ä¸ª+20%ä¼¤å®³'] },
    { id: 'rapidfire',    name: 'é«˜é€Ÿå¼¹åŒ£', desc: 'æé«˜å°„å‡»é¢‘ç‡', rarity: 'rare',
      upgrades: ['+32%å°„é€Ÿ', '+53%å°„é€Ÿ', '+68%å°„é€Ÿ', '+78%å°„é€Ÿ', '+86%å°„é€Ÿ'] },
    // â”€â”€ SONAR (4) â”€â”€
    { id: 'echo',         name: 'å›å£°å»¶é•¿', desc: 'å£°çº³æ ‡è®°æŒç»­æ›´ä¹…', rarity: 'common',
      upgrades: ['+57%æ ‡è®°', '+89%æ ‡è®°', '+109%æ ‡è®°', '+123%æ ‡è®°', '+133%æ ‡è®°'] },
    { id: 'doublepulse',  name: 'åŒé‡è„‰å†²', desc: 'ä¸€æ¬¡é‡Šæ”¾å¤šåœˆå£°çº³æ³¢', rarity: 'rare',
      upgrades: ['2åœˆ', '2åœˆ+èŒƒå›´', '3åœˆ', '3åœˆ+èŒƒå›´', '3åœˆ+å¤§èŒƒå›´'] },
    { id: 'sonareff',     name: 'å£°çº³å‡è€—', desc: 'é™ä½å£°çº³èƒ½é‡æ¶ˆè€—', rarity: 'common',
      upgrades: ['-5æ¶ˆè€—', '-8æ¶ˆè€—', '-10æ¶ˆè€—', '-12æ¶ˆè€—', '-13æ¶ˆè€—'] },
    // â”€â”€ SURVIVAL (3) â”€â”€
    { id: 'speedchip',    name: 'é€Ÿåº¦èŠ¯ç‰‡', desc: 'æé«˜ç§»åŠ¨é€Ÿåº¦', rarity: 'common',
      upgrades: ['+23%', '+35%', '+42%', '+47%', '+50%'] },
    { id: 'energyharvest',name: 'èƒ½é‡å›æ”¶', desc: 'å‡»æ€æ•Œäººå›å¤èƒ½é‡', rarity: 'common',
      upgrades: ['+7èƒ½é‡', '+12èƒ½é‡', '+14èƒ½é‡', '+16èƒ½é‡', '+17èƒ½é‡'] },
    { id: 'energyshield', name: 'èƒ½é‡æŠ¤ç›¾', desc: 'èƒ½é‡>30%æ—¶å‡å°‘å—ä¼¤', rarity: 'rare',
      upgrades: ['16%å‡ä¼¤', '24%å‡ä¼¤', '30%å‡ä¼¤', '34%å‡ä¼¤', '37%å‡ä¼¤'] },
    // â”€â”€ ENERGY (3) â€” æ ¸å¿ƒè§£å†³åæœŸèƒ½é‡é—®é¢˜ â”€â”€
    { id: 'bulleteff',    name: 'èŠ‚èƒ½å¼¹åŒ£', desc: 'é™ä½å°„å‡»èƒ½é‡æ¶ˆè€—', rarity: 'common',
      upgrades: ['-1.3æ¶ˆè€—', '-2æ¶ˆè€—', '-2.5æ¶ˆè€—', '-2.8æ¶ˆè€—', '-3æ¶ˆè€—'] },
    { id: 'quickcharge',  name: 'å¿«é€Ÿå……èƒ½', desc: 'åŠ å¿«èƒ½é‡å›å¤é€Ÿåº¦', rarity: 'rare',
      upgrades: ['+50%å›å¤', '+75%å›å¤', '+90%å›å¤', '+100%å›å¤', '+107%å›å¤'] },
    { id: 'energycore',   name: 'èƒ½é‡æ ¸å¿ƒ', desc: 'å¤§å¹…æé«˜èƒ½é‡ä¸Šé™å’ŒåŸºç¡€å›å¤', rarity: 'epic',
      upgrades: ['+37ä¸Šé™+2/s', '+58ä¸Šé™+3.1/s', '+71ä¸Šé™+3.8/s', '+80ä¸Šé™+4.3/s', '+87ä¸Šé™+4.7/s'] },
    // â”€â”€ BUILD-DEFINING (3) â€” è®©å£°çº³æµå’Œç”Ÿå­˜æµæœ‰æ ¸å¿ƒæ”¯æŸ± â”€â”€
    { id: 'sonarslow',    name: 'å£°æ³¢å¹²æ‰°', desc: 'è¢«å£°çº³ç…§äº®çš„æ•Œäººç§»åŠ¨å‡é€Ÿ', rarity: 'rare',
      upgrades: ['å‡é€Ÿ25%', 'å‡é€Ÿ40%', 'å‡é€Ÿ50%', 'å‡é€Ÿ58%', 'å‡é€Ÿ65%'] },
    { id: 'regen',        name: 'å†ç”Ÿè£…ç”²', desc: 'æŒç»­ç¼“æ…¢å›å¤ç”Ÿå‘½å€¼', rarity: 'rare',
      upgrades: ['0.6HP/s', '1.0HP/s', '1.2HP/s', '1.35HP/s', '1.47HP/s'] },
];
// Pre-build idâ†’card lookup for O(1) access
const CARD_MAP = {};
for (const c of CARD_DEFS) CARD_MAP[c.id] = c;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PLAYER  (100 HP system)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Player {
    constructor() {
        this.x = W / 2; this.y = H / 2;
        this.radius = 8;
        this.speed = 4;
        this.hp = 70; this.maxHp = 70;
        this.invTimer = 0;
        this.energy = 100; this.maxEnergy = 100;
        this.energyRegen = 10;
        this.sonarCost = 25;
        this.shootCost = 8;
        this.shootCooldown = 0;
        this.shootInterval = 0.25;
        this.shieldActive = false;
        this.shieldBreakTimer = 0;
        this.scoreBonus = 0;
        this.scoreBonusTimer = 0;
        this.cards = new Map();         // card_id -> level (stacks infinitely)
    }
    cardLv(id) { return this.cards.get(id) || 0; }
    // Get effective max energy (affected by energycore card)
    getMaxEnergy() {
        const lv = this.cardLv('energycore');
        return this.maxEnergy + Math.round(130 * lv / (lv + 2.5));
    }
    update() {
        if (cardSelectActive) return;
        if (this.shieldBreakTimer > 0) this.shieldBreakTimer -= dt;
        if (this.scoreBonusTimer > 0) {
            this.scoreBonusTimer -= dt;
            if (frameCount % 6 === 0) score++;
        }

        // â”€â”€ Card effects (Lv.1-5, diminishing returns: val = max * lv/(lv+k)) â”€â”€
        const speedLv = this.cardLv('speedchip');
        const speedMul = 1 + 0.7 * speedLv / (speedLv + 2);       // cap ~+50%, Lv1=+23%
        const chargeLv = this.cardLv('quickcharge');
        const regenMul = 1 + 1.5 * chargeLv / (chargeLv + 2);     // cap ~+107%, Lv1=+50%
        const coreLv = this.cardLv('energycore');
        const extraMaxE = Math.round(130 * coreLv / (coreLv + 2.5)); // cap ~+87
        const extraRegen = 7 * coreLv / (coreLv + 2.5);              // cap ~+4.7/s
        const effectiveMaxE = this.maxEnergy + extraMaxE;

        let dx = 0, dy = 0;
        if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
        if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
        if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
        if (keys['KeyD'] || keys['ArrowRight']) dx += 1;
        if (dx || dy) {
            const len = Math.hypot(dx, dy);
            dx /= len; dy /= len;
            this.x += dx * this.speed * speedMul;
            this.y += dy * this.speed * speedMul;
            emitNoise(this.x, this.y, 80);
        }
        for (const w of walls) {
            if (w instanceof FragileWall && !w.alive) continue;
            const push = pushCircleOutOfRect(this.x, this.y, this.radius, w.x, w.y, w.w, w.h);
            if (push) { this.x = push.x; this.y = push.y; }
        }
        this.x = clamp(this.x, this.radius, W - this.radius);
        this.y = clamp(this.y, this.radius, H - this.radius);
        this.energy = Math.min(effectiveMaxE, this.energy + (this.energyRegen * regenMul + extraRegen) * dt);
        if (this.invTimer > 0) this.invTimer -= dt;
        // Regen Armor: passive HP recovery (cap ~1.47 HP/s at Lv.5)
        const regenLv = this.cardLv('regen');
        if (regenLv > 0) {
            const hpRegen = 2.2 * regenLv / (regenLv + 2.5); // Lv1=0.63, Lv3=1.20, Lv5=1.47
            this.hp = Math.min(this.maxHp, this.hp + hpRegen * dt);
        }
        this.shootCooldown -= dt;

        // Bullet efficiency: diminishing cost reduction (cap ~-3.0)
        const bulletEffLv = this.cardLv('bulleteff');
        const costReduce = 4.5 * bulletEffLv / (bulletEffLv + 2.5);
        const actualShootCost = Math.max(3.5, this.shootCost - costReduce);
        if (mouse.left && this.shootCooldown <= 0 && this.energy >= actualShootCost) {
            this.shoot(actualShootCost);
        }
    }
    shoot(cost) {
        const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
        const scatterLv = this.cardLv('scatter');
        const pierceLv = this.cardLv('pierce');
        const rapidLv = this.cardLv('rapidfire');

        // Scatter: always odd counts (center bullet for aiming)
        // lv0=1, lv1=3, lv2=5, lv3=7, lv4=7, lv5=7
        const bulletCount = [1, 3, 5, 7, 7, 7][scatterLv] || 1;
        const spreadAngle = scatterLv > 0 ? 0.24 : 0;
        // Scatter Lv4-5: bonus damage per bullet
        const scatterDmgBonus = scatterLv >= 5 ? 1.2 : scatterLv >= 4 ? 1.1 : 1;
        // Pierce: lv1=1, lv2=2, lv3-5=3 max, but higher levels add +10% damage
        const pierceCount = Math.min(pierceLv, 3);
        const pierceDmgBonus = pierceLv > 2 ? 1 + (pierceLv - 2) * 0.1 : 1;
        for (let i = 0; i < bulletCount; i++) {
            let a = angle;
            if (bulletCount > 1) {
                a = angle - spreadAngle * (bulletCount - 1) / 2 + spreadAngle * i;
            }
            // Scatter damage falloff: center bullet full damage, side bullets 0.6x
            const centerIdx = Math.floor(bulletCount / 2);
            const isCenter = (i === centerIdx) || bulletCount === 1;
            const scatterPenalty = isCenter ? 1 : 0.6;
            const b = new Bullet(this.x, this.y, a, 12, pierceDmgBonus * scatterDmgBonus * scatterPenalty, 'player');
            b.pierceLeft = pierceCount;
            bullets.push(b);
        }
        if (cost === undefined) cost = this.shootCost;
        // Scatter energy cost multiplier: more bullets = more energy
        // 1 bullet = 1x, 3 bullets = 1.4x, 5 bullets = 1.8x, 7 bullets = 2.2x
        const scatterCostMul = 1 + (bulletCount - 1) * 0.2;
        this.energy -= cost * scatterCostMul;
        // Rapid fire: diminishing returns (cap ~86% faster at Lv.5)
        const rapidMul = 1 - 0.88 * rapidLv / (rapidLv + 2);  // Lv1=0.71, Lv3=0.47, Lv5=0.37
        this.shootCooldown = this.shootInterval * Math.max(0.12, rapidMul);
        emitNoise(this.x, this.y, 200);
        SFX.shoot();
    }
    pulse() {
        const sonarEffLv = this.cardLv('sonareff');
        const costReduce = 19 * sonarEffLv / (sonarEffLv + 2.5); // cap ~-13
        const actualCost = Math.max(6, this.sonarCost - costReduce);
        if (this.energy >= actualCost) {
            this.energy -= actualCost;
            SFX.sonar();
            pulses.push(new Pulse(this.x, this.y));
            // Double pulse: Lv1-2 = 2 pulses, Lv3-4 = 3 pulses, Lv5 = 3 pulses
            // Higher levels also increase pulse range
            const dpLv = this.cardLv('doublepulse');
            const extraPulses = dpLv >= 3 ? 2 : dpLv >= 1 ? 1 : 0;
            const rangeBonus = dpLv >= 4 ? 60 : dpLv >= 2 ? 30 : 0;
            for (let i = 1; i <= extraPulses; i++) {
                const delay = i * 280;
                setTimeout(() => {
                    if (playing) {
                        const p = new Pulse(this.x, this.y);
                        p.maxRadius += rangeBonus;
                        pulses.push(p);
                    }
                }, delay);
            }
            spawnParticles(this.x, this.y, 12, '#00f2ff', 2);
            emitNoise(this.x, this.y, 350);
            sessionStats.noSonarTimer = 0; // reset no-sonar timer
        }
    }
    takeDamage(amount) {
        if (this.invTimer > 0) return;
        const dmg = amount || 10;

        if (this.shieldActive) {
            // Shield DETONATION: absorb hit + explode outward
            this.shieldActive = false;
            this.shieldBreakTimer = 0.6;
            this.invTimer = 1.5; // generous invincibility after detonation
            shakeTimer = 0.15;

            // â”€â”€ Shield explosion: damage/kill nearby enemies â”€â”€
            const blastRadius = 120;
            for (const e of enemies) {
                if (!e.alive) continue;
                const d = dist(this.x, this.y, e.x, e.y);
                if (d < blastRadius) {
                    // Inner zone (< 60px): instant kill (1HP enemies die, others take 3 dmg)
                    // Outer zone (60-120px): 1 dmg + strong knockback
                    const inner = d < 60;
                    const blastDmg = inner ? 3 : 1;
                    const wasAliveBeforeBlast = e.hp > 0;
                    e.takeDamage(blastDmg);
                    if (wasAliveBeforeBlast && e.hp <= 0) sessionStats.shieldKills++;
                    // Knockback: push enemy away from player
                    if (e.alive) {
                        const angle = Math.atan2(e.y - this.y, e.x - this.x);
                        const pushForce = inner ? 8 : 5;
                        e.x += Math.cos(angle) * pushForce * 10;
                        e.y += Math.sin(angle) * pushForce * 10;
                        e.state = 'search'; // disrupted â€” lose tracking
                        e.stateTimer = 0;
                    }
                }
            }
            // Also destroy enemy bullets in blast radius
            for (const b of bullets) {
                if (!b.alive || b.owner !== 'enemy') continue;
                if (dist(this.x, this.y, b.x, b.y) < blastRadius) {
                    b.alive = false;
                    spawnParticles(b.x, b.y, 3, '#66ccff', 2);
                }
            }

            // Big visual feedback: blue explosion ring + particles
            spawnParticles(this.x, this.y, 15, '#66ccff', 5);
            spawnParticles(this.x, this.y, 6, '#ffffff', 3);
            // Expanding shock ring (reuse Pulse visual)
            const shockPulse = new Pulse(this.x, this.y);
            shockPulse.maxRadius = blastRadius;
            shockPulse.speed = 12;
            pulses.push(shockPulse);

            pickupTexts.push({ x: this.x, y: this.y - 25, text: 'SHIELD BLAST!', color: '#66ccff', life: 1.5 });
            SFX.shieldBreak();
            return; // no HP lost
        }

        // Energy shield: reduce damage when energy > 50% of max
        let finalDmg = dmg;
        const eshieldLv = this.cardLv('energyshield');
        if (eshieldLv > 0 && this.energy > this.getMaxEnergy() * 0.3) {
            const reduction = 0.55 * eshieldLv / (eshieldLv + 2.5); // cap ~37%
            finalDmg = Math.ceil(dmg * (1 - reduction));
            spawnParticles(this.x, this.y, 6, '#00aaff', 2);
        }

        this.hp -= finalDmg;
        this.invTimer = 0.8;
        shakeTimer = 0.12;
        damageFlash = 0.2;
        spawnParticles(this.x, this.y, 12, '#ff2266', 3);
        SFX.playerHit();
        sessionStats.noDmgTimer = 0; // reset no-damage timer
        if (this.hp <= 0) { this.hp = 0; gameOver(); }
    }
    draw() {
        const blinkOff = this.invTimer > 0 && Math.floor(this.invTimer * 14) % 2 === 0;
        if (blinkOff) return;

        // Soft ambient light â€” smooth exponential falloff, no hard edge
        const r = 160;
        const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r);
        g.addColorStop(0, 'rgba(0,242,255,0.13)');
        g.addColorStop(0.15, 'rgba(0,242,255,0.09)');
        g.addColorStop(0.35, 'rgba(0,242,255,0.05)');
        g.addColorStop(0.6, 'rgba(0,242,255,0.02)');
        g.addColorStop(0.85, 'rgba(0,242,255,0.005)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.fill();

        // Player dot
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#00f2ff';
        ctx.fill();
        // Soft glow layer (no shadowBlur)
        ctx.globalAlpha = 0.25;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Shield visual
        if (this.shieldActive) {
            // Prominent glowing shield ring â€” clearly visible
            const pulse = 0.6 + Math.sin(performance.now() * 0.005) * 0.15;
            const shieldR = this.radius + 10;
            // Outer glow fill
            const sg = ctx.createRadialGradient(this.x, this.y, shieldR - 4, this.x, this.y, shieldR + 8);
            sg.addColorStop(0, 'rgba(102,204,255,0)');
            sg.addColorStop(0.5, 'rgba(102,204,255,' + (pulse * 0.2) + ')');
            sg.addColorStop(1, 'rgba(102,204,255,0)');
            ctx.fillStyle = sg;
            ctx.beginPath(); ctx.arc(this.x, this.y, shieldR + 8, 0, Math.PI * 2); ctx.fill();
            // Main ring
            ctx.beginPath();
            ctx.arc(this.x, this.y, shieldR, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(102,220,255,' + pulse + ')';
            ctx.lineWidth = 2.5;
            ctx.stroke();
            // Inner thin ring
            ctx.beginPath();
            ctx.arc(this.x, this.y, shieldR - 3, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(102,220,255,' + (pulse * 0.35) + ')';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.lineWidth = 1;
        } else if (this.shieldBreakTimer > 0) {
            // Shatter animation: flickering fragments expanding outward
            const t = 1 - this.shieldBreakTimer / 0.6;
            const fragAlpha = (1 - t) * 0.7;
            const fragR = this.radius + 7 + t * 20;
            ctx.strokeStyle = 'rgba(102,204,255,' + fragAlpha + ')';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 6; i++) {
                const a = (Math.PI * 2 / 6) * i + t * 0.5;
                const len = 4 + t * 8;
                const fx = this.x + Math.cos(a) * fragR;
                const fy = this.y + Math.sin(a) * fragR;
                ctx.beginPath();
                ctx.moveTo(fx - Math.cos(a + 0.3) * len, fy - Math.sin(a + 0.3) * len);
                ctx.lineTo(fx + Math.cos(a + 0.3) * len, fy + Math.sin(a + 0.3) * len);
                ctx.stroke();
            }
            ctx.lineWidth = 1;
        }

        // Score bonus indicator
        if (this.scoreBonusTimer > 0) {
            ctx.fillStyle = '#ffcc00';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.globalAlpha = 0.7;
            ctx.fillText('Ã—2', this.x, this.y - this.radius - 10);
            ctx.globalAlpha = 1;
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PULSE (Sonar)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let pulseIdCounter = 0;
class Pulse {
    constructor(x, y) {
        this.id = ++pulseIdCounter;
        this.x = x; this.y = y;
        this.radius = 10;
        this.speed = 8;
        this.maxRadius = 350; // tactical local scan, not full-screen
        this.alive = true;
    }
    update() {
        this.radius += this.speed * dt * 60;
        if (this.radius >= this.maxRadius) this.alive = false;
    }
    draw() {
        const alpha = 1 - this.radius / this.maxRadius;
        if (alpha <= 0) return;

        // Main sonar ring
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0,242,255,' + (alpha * 0.45) + ')';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.lineWidth = 1;
        // Soft glow band (thinner)
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0,242,255,' + (alpha * 0.08) + ')';
        ctx.lineWidth = 16;
        ctx.stroke();
        ctx.lineWidth = 1;

        // â”€â”€ Sonar shadow: dark cone behind each wall (capped for perf) â”€â”€
        let shadowCount = 0;
        const maxShadows = 12;
        const shadowFill = 'rgba(5,5,5,' + clamp(alpha * 0.85, 0, 0.55) + ')';
        const hitAlpha = alpha * 0.4;
        for (const w of walls) {
            if (shadowCount >= maxShadows) break;
            if (w instanceof FragileWall && !w.alive) continue;
            const closestX = clamp(this.x, w.x, w.x + w.w);
            const closestY = clamp(this.y, w.y, w.y + w.h);
            const wallDist = dist(this.x, this.y, closestX, closestY);
            if (this.radius < wallDist - 5) continue;

            shadowCount++;
            const corners = [
                [w.x, w.y], [w.x + w.w, w.y],
                [w.x + w.w, w.y + w.h], [w.x, w.y + w.h]
            ];
            const wcx = w.x + w.w / 2, wcy = w.y + w.h / 2;
            const refA = Math.atan2(wcy - this.y, wcx - this.x);
            let minRA = Infinity, maxRA = -Infinity, c1, c2;
            for (const [cx, cy] of corners) {
                let ra = Math.atan2(cy - this.y, cx - this.x) - refA;
                while (ra > Math.PI) ra -= Math.PI * 2;
                while (ra < -Math.PI) ra += Math.PI * 2;
                if (ra < minRA) { minRA = ra; c1 = [cx, cy]; }
                if (ra > maxRA) { maxRA = ra; c2 = [cx, cy]; }
            }

            const shadowDist = this.maxRadius + 80;
            const a1 = Math.atan2(c1[1] - this.y, c1[0] - this.x);
            const a2 = Math.atan2(c2[1] - this.y, c2[0] - this.x);
            ctx.fillStyle = shadowFill;
            ctx.beginPath();
            ctx.moveTo(c1[0], c1[1]);
            ctx.lineTo(this.x + Math.cos(a1) * shadowDist, this.y + Math.sin(a1) * shadowDist);
            ctx.lineTo(this.x + Math.cos(a2) * shadowDist, this.y + Math.sin(a2) * shadowDist);
            ctx.lineTo(c2[0], c2[1]);
            ctx.closePath();
            ctx.fill();

            // Edge glow where pulse hits wall face
            if (Math.abs(wallDist - this.radius) < 20) {
                ctx.strokeStyle = 'rgba(0,242,255,' + hitAlpha + ')';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.rect(w.x, w.y, w.w, w.h);
                ctx.stroke();
                ctx.lineWidth = 1;
            }
        }
    }
    hitsPoint(px, py) {
        const d = dist(this.x, this.y, px, py);
        return d <= this.radius && d >= this.radius - 50;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BULLET
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Bullet {
    constructor(x, y, angle, speed, damage, owner) {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.speed = speed;
        this.damage = damage;
        this.owner = owner;
        this.alive = true;
        this.traveled = 0;
        this.maxRange = owner === 'player' ? 400 : 600;
        this.markedTimer = owner === 'player' ? 999 : 0;
        this.radius = 3;
        this.color = owner === 'player' ? '#00f2ff' : '#ff4466';
        this.pierceLeft = 0; // pierce card: how many enemies can pass through
    }
    update() {
        this.x += this.vx * dt * 60;
        this.y += this.vy * dt * 60;
        this.traveled += this.speed * dt * 60;
        if (this.traveled > this.maxRange) { this.alive = false; return; }
        if (this.x < -20 || this.x > W + 20 || this.y < -20 || this.y > H + 20) { this.alive = false; return; }
        if (this.markedTimer > 0) this.markedTimer -= dt;
        // Wall collision: bullets die on solid wall hit (reflect/fragile handled in handleCollisions)
        const bx = this.x, by = this.y;
        for (const w of walls) {
            if (w instanceof ReflectWall) continue;
            if (w instanceof FragileWall) continue; // both alive/dead skipped â€” handled in handleCollisions
            if (bx >= w.x && bx <= w.x + w.w && by >= w.y && by <= w.y + w.h) {
                this.alive = false; return;
            }
        }
    }
    draw() {
        const visible = this.owner === 'player' ? 1 : (this.markedTimer > 0 ? 1 : 0.03);
        ctx.globalAlpha = visible;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        if (visible > 0.5) {
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x - this.vx * 0.3, this.y - this.vy * 0.3);
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = visible * 0.5;
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SUPPLY CRATE (only visible when sonar-lit!)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class SupplyCrate {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.alive = true;
        this.markedTimer = 0;
        this.size = 10;
        // 4 types: hp, energy, shield, data
        const roll = Math.random();
        if (roll < 0.25) {
            this.crateType = 'hp';
            this.color = '#ff66aa';
            this.icon = '+';
        } else if (roll < 0.5) {
            this.crateType = 'energy';
            this.color = '#66ffcc';
            this.icon = 'E';
        } else if (roll < 0.75) {
            this.crateType = 'shield';
            this.color = '#66ccff';
            this.icon = 'S';
        } else {
            this.crateType = 'data';
            this.color = '#ffcc00';
            this.icon = 'D';
        }
        this.pulsePhase = rand(0, Math.PI * 2);
        this.hintTimer = 0; // periodic faint hint pulse
    }
    update() {
        if (this.markedTimer > 0) this.markedTimer -= dt;

        // Hint pulse: every 5s, emit a VERY faint visual hint (no sonar needed)
        // This encourages players to sonar in that direction
        this.hintTimer += dt;

        // Pickup: player touches a VISIBLE crate
        if (this.markedTimer > 0 && dist(this.x, this.y, player.x, player.y) < this.size + player.radius + 8) {
            this.alive = false;
            SFX.pickup();
            // BIG particle burst on pickup
            spawnParticles(this.x, this.y, 10, this.color, 3);
            spawnParticles(this.x, this.y, 4, '#ffffff', 2);
            let label = '';
            switch (this.crateType) {
                case 'hp':
                    player.hp = Math.min(player.maxHp, player.hp + 15);
                    label = 'HP +15';
                    break;
                case 'energy':
                    player.energy = Math.min(player.getMaxEnergy(), player.energy + 40);
                    label = 'ENERGY +40';
                    break;
                case 'shield':
                    player.shieldActive = true;
                    player.shieldBreakTimer = 0;
                    label = 'SHIELD ON!';
                    break;
                case 'data':
                    score += 50;
                    player.scoreBonusTimer = 8;
                    label = 'x2 SCORE 8s!';
                    break;
            }
            // Floating pickup text
            pickupTexts.push({
                x: this.x, y: this.y - 10,
                text: label, color: this.color, life: 1.5
            });
        }
    }
    draw() {
        // Hint pulse: faint ring every 5 seconds (even without sonar)
        if (this.hintTimer > 5) {
            this.hintTimer = 0;
        }
        if (this.hintTimer < 0.5 && this.markedTimer <= 0) {
            const t = this.hintTimer / 0.5;
            const r = 15 + t * 30;
            const a = (1 - t) * 0.08;
            ctx.beginPath();
            ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
            ctx.strokeStyle = this.color.replace(')', ',' + a + ')').replace('rgb', 'rgba');
            // Fallback for hex colors
            ctx.globalAlpha = a;
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.globalAlpha = 1;
            ctx.lineWidth = 1;
        }

        // Full visibility only when sonar-marked
        if (this.markedTimer <= 0) return;
        const vis = clamp(this.markedTimer / 0.5, 0, 1);
        const pulse = 0.8 + Math.sin(performance.now() * 0.004 + this.pulsePhase) * 0.2;
        ctx.globalAlpha = vis * pulse;
        ctx.save();
        ctx.translate(this.x, this.y);
        const s = this.size;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        // Diamond shape for crates
        ctx.beginPath();
        ctx.moveTo(0, -s);
        ctx.lineTo(s, 0);
        ctx.lineTo(0, s);
        ctx.lineTo(-s, 0);
        ctx.closePath();
        ctx.stroke();
        // Icon inside
        ctx.fillStyle = this.color;
        ctx.font = 'bold 11px monospace';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(this.icon, 0, 1);
        ctx.restore();
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WALL SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Wall {
    constructor(x, y, w, h) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.glowPhase = rand(0, Math.PI * 2);
    }
    draw() {
        // Dark wall body
        ctx.fillStyle = 'rgba(20,25,35,0.95)';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        // Neon edge glow
        const g = 0.15 + Math.sin(performance.now() * 0.001 + this.glowPhase) * 0.05;
        ctx.strokeStyle = 'rgba(0,180,220,' + g + ')';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(this.x + 0.5, this.y + 0.5, this.w - 1, this.h - 1);
        ctx.lineWidth = 1;
        // Inner subtle grid lines
        ctx.strokeStyle = 'rgba(0,120,160,0.06)';
        for (let gx = this.x + 20; gx < this.x + this.w; gx += 20) {
            ctx.beginPath(); ctx.moveTo(gx, this.y); ctx.lineTo(gx, this.y + this.h); ctx.stroke();
        }
        for (let gy = this.y + 20; gy < this.y + this.h; gy += 20) {
            ctx.beginPath(); ctx.moveTo(this.x, gy); ctx.lineTo(this.x + this.w, gy); ctx.stroke();
        }
    }
}

// Circle vs AABB collision â€” push circle out, return new position or null
function pushCircleOutOfRect(cx, cy, cr, rx, ry, rw, rh) {
    const closestX = clamp(cx, rx, rx + rw);
    const closestY = clamp(cy, ry, ry + rh);
    const dx = cx - closestX;
    const dy = cy - closestY;
    const dist2 = dx * dx + dy * dy;
    if (dist2 < cr * cr) {
        if (dist2 === 0) {
            // Circle center inside rect â€” push to nearest edge
            const dLeft = cx - rx, dRight = (rx + rw) - cx;
            const dTop = cy - ry, dBot = (ry + rh) - cy;
            const minD = Math.min(dLeft, dRight, dTop, dBot);
            if (minD === dLeft) return { x: rx - cr, y: cy };
            if (minD === dRight) return { x: rx + rw + cr, y: cy };
            if (minD === dTop) return { x: cx, y: ry - cr };
            return { x: cx, y: ry + rh + cr };
        }
        const d = Math.sqrt(dist2);
        const overlap = cr - d;
        return { x: cx + (dx / d) * overlap, y: cy + (dy / d) * overlap };
    }
    return null;
}

// Point inside any wall?
function pointInWall(px, py) {
    for (const w of walls) {
        if (w instanceof FragileWall && !w.alive) continue;
        if (px >= w.x && px <= w.x + w.w && py >= w.y && py <= w.y + w.h) return true;
    }
    return false;
}

// Line segment intersects AABB? (for sonar occlusion)
function lineHitsWall(x1, y1, x2, y2) {
    for (const w of walls) {
        if (w instanceof FragileWall && !w.alive) continue;
        if (lineIntersectsAABB(x1, y1, x2, y2, w.x, w.y, w.w, w.h)) return true;
    }
    return false;
}
function lineIntersectsAABB(x1, y1, x2, y2, rx, ry, rw, rh) {
    let tmin = 0, tmax = 1;
    const dx = x2 - x1, dy = y2 - y1;
    // X slab
    if (Math.abs(dx) < 0.0001) {
        if (x1 < rx || x1 > rx + rw) return false;
    } else {
        let t1 = (rx - x1) / dx, t2 = (rx + rw - x1) / dx;
        if (t1 > t2) { const tmp = t1; t1 = t2; t2 = tmp; }
        tmin = Math.max(tmin, t1); tmax = Math.min(tmax, t2);
        if (tmin > tmax) return false;
    }
    // Y slab
    if (Math.abs(dy) < 0.0001) {
        if (y1 < ry || y1 > ry + rh) return false;
    } else {
        let t1 = (ry - y1) / dy, t2 = (ry + rh - y1) / dy;
        if (t1 > t2) { const tmp = t1; t1 = t2; t2 = tmp; }
        tmin = Math.max(tmin, t1); tmax = Math.min(tmax, t2);
        if (tmin > tmax) return false;
    }
    return true;
}

// Generate walls for game phase
function generateWalls(phase) {
    walls = [];
    specialWalls = [];
    if (phase < 1) return; // Phase 0: no walls
    const margin = 100;
    let solidCount, fragileCount = 0, reflectCount = 0;
    if (phase === 1) { solidCount = Math.floor(rand(5, 8)); }
    else if (phase === 2) { solidCount = Math.floor(rand(6, 9)); fragileCount = Math.floor(rand(2, 4)); }
    else { solidCount = Math.floor(rand(5, 7)); fragileCount = Math.floor(rand(2, 4)); reflectCount = Math.floor(rand(2, 4)); }
    const totalCount = solidCount + fragileCount + reflectCount;
    for (let i = 0; i < totalCount; i++) {
        let tries = 0, placed = false;
        while (tries < 20 && !placed) {
            tries++;
            const horizontal = Math.random() > 0.5;
            const w = horizontal ? rand(60, 160) : rand(20, 40);
            const h = horizontal ? rand(20, 40) : rand(60, 160);
            const x = rand(margin, W - margin - w);
            const y = rand(margin, H - margin - h);
            // Don't place too close to player spawn (center)
            const cx = x + w / 2, cy = y + h / 2;
            if (dist(cx, cy, W / 2, H / 2) < 150) continue;
            // Don't overlap existing walls (with gap)
            let overlap = false;
            for (const ow of walls) {
                if (x < ow.x + ow.w + 40 && x + w > ow.x - 40 &&
                    y < ow.y + ow.h + 40 && y + h > ow.y - 40) {
                    overlap = true; break;
                }
            }
            if (!overlap) {
                let nw;
                if (i < solidCount) nw = new Wall(x, y, w, h);
                else if (i < solidCount + fragileCount) nw = new FragileWall(x, y, w, h);
                else nw = new ReflectWall(x, y, w, h);
                walls.push(nw);
                if (nw instanceof FragileWall || nw instanceof ReflectWall) specialWalls.push(nw);
                placed = true;
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CARD CRATE (triggers card selection)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class CardCrate {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.alive = true;
        this.markedTimer = 0;
        this.size = 14;
        this.color = '#ffaa00';
        this.hintTimer = 0;
        this.lifespan = 20; // disappears after 20s
        this.pulsePhase = rand(0, Math.PI * 2);
    }
    update() {
        if (this.markedTimer > 0) this.markedTimer -= dt;
        this.hintTimer += dt;
        this.lifespan -= dt;
        if (this.lifespan <= 0) { this.alive = false; return; }
        // Pickup: player touches a VISIBLE card crate (guard against multi-trigger)
        if (!this.alive) return;
        if (this.markedTimer > 0 && !cardSelectActive && dist(this.x, this.y, player.x, player.y) < this.size + player.radius + 10) {
            this.alive = false;
            // Also kill any other nearby card crates to prevent multi-trigger
            for (const cc of cardCrates) {
                if (cc !== this && cc.alive && dist(cc.x, cc.y, player.x, player.y) < 60) {
                    cc.alive = false;
                }
            }
            spawnParticles(this.x, this.y, 12, '#ffaa00', 3);
            spawnParticles(this.x, this.y, 5, '#ffffff', 2);
            pickupTexts.push({ x: this.x, y: this.y - 15, text: 'CARD!', color: '#ffaa00', life: 1.5 });
            showCardSelection();
        }
    }
    draw() {
        // Hint pulse (stronger than supply crate)
        if (this.hintTimer > 4) this.hintTimer = 0;
        if (this.hintTimer < 0.6 && this.markedTimer <= 0) {
            const t = this.hintTimer / 0.6;
            const r = 18 + t * 35;
            ctx.globalAlpha = (1 - t) * 0.12;
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.stroke();
            ctx.globalAlpha = 1; ctx.lineWidth = 1;
        }
        if (this.markedTimer <= 0) return;
        const vis = clamp(this.markedTimer / 0.5, 0, 1);
        const pulse = 0.8 + Math.sin(performance.now() * 0.005 + this.pulsePhase) * 0.2;
        ctx.globalAlpha = vis * pulse;
        ctx.save();
        ctx.translate(this.x, this.y);
        const s = this.size;
        // Octagon shape (special)
        ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 2.5;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const a = (Math.PI * 2 / 8) * i - Math.PI / 8;
            const px = Math.cos(a) * s, py = Math.sin(a) * s;
            i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath(); ctx.stroke();
        // "C" icon
        ctx.fillStyle = '#ffaa00';
        ctx.font = 'bold 12px monospace';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('C', 0, 1);
        ctx.restore();
        ctx.globalAlpha = 1; ctx.lineWidth = 1;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CARD SELECTION LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Card route definitions for smart offering
const CARD_ROUTES = {
    weapon: ['scatter', 'pierce', 'rapidfire'],
    sonar:  ['echo', 'doublepulse', 'sonareff', 'sonarslow'],
    survival: ['speedchip', 'energyharvest', 'energyshield', 'regen'],
    energy: ['bulleteff', 'quickcharge', 'energycore']
};
function getPlayerRoute() {
    // Find the route the player has invested most in
    let bestRoute = null, bestTotal = 0;
    for (const [route, ids] of Object.entries(CARD_ROUTES)) {
        let total = 0;
        for (const id of ids) total += player.cardLv(id);
        if (total > bestTotal) { bestTotal = total; bestRoute = route; }
    }
    return bestTotal >= 2 ? bestRoute : null; // only bias if invested â‰¥2 levels
}
function rollCards(count) {
    // Weighted random, skip maxed-out cards (Lv.5)
    const available = CARD_DEFS.filter(c => player.cardLv(c.id) < 5);
    if (available.length === 0) return CARD_DEFS.slice(0, count); // all maxed fallback

    // Time-based rarity boost: rare/epic more common as game progresses
    const rarityBoost = clamp(gameTime / 300, 0, 1); // 0â†’1 over 5 min
    const pool = [];
    for (const c of available) {
        let weight = c.rarity === 'common' ? 60 : c.rarity === 'rare' ? 30 : 10;
        // Boost rare/epic chances over time
        if (c.rarity === 'rare') weight += Math.round(20 * rarityBoost);
        if (c.rarity === 'epic') weight += Math.round(15 * rarityBoost);
        for (let i = 0; i < weight; i++) pool.push(c);
    }
    const selected = [];
    const usedIds = new Set();
    while (selected.length < count && selected.length < available.length) {
        const pick = pool[Math.floor(Math.random() * pool.length)];
        if (!usedIds.has(pick.id)) {
            usedIds.add(pick.id);
            selected.push(pick);
        }
    }

    // Smart offering: guarantee 1 card from player's invested route (if any)
    const investedRoute = getPlayerRoute();
    if (investedRoute && selected.length >= 2) {
        const routeIds = new Set(CARD_ROUTES[investedRoute]);
        const hasRouteCard = selected.some(c => routeIds.has(c.id));
        if (!hasRouteCard) {
            // Replace the last card with one from the invested route
            const routeAvail = available.filter(c => routeIds.has(c.id) && !usedIds.has(c.id));
            if (routeAvail.length > 0) {
                const replacement = routeAvail[Math.floor(Math.random() * routeAvail.length)];
                selected[selected.length - 1] = replacement;
            }
        }
    }

    return selected;
}

function showCardSelection(count) {
    count = count || 3;
    cardSelectActive = true;
    const overlay = document.getElementById('cardOverlay');
    const container = document.getElementById('cardContainer');
    container.innerHTML = '';
    const cards = rollCards(count);
    cards.forEach((card, idx) => {
        const currentLv = player.cardLv(card.id);
        const nextLv = currentLv + 1;
        const upgradeDesc = nextLv <= card.upgrades.length
            ? card.upgrades[nextLv - 1]
            : card.upgrades[card.upgrades.length - 1];
        const div = document.createElement('div');
        div.className = 'card-item rarity-' + card.rarity;
        const lvTag = currentLv > 0 ? '<div class="card-level">Lv.' + currentLv + ' â†’ ' + nextLv + '</div>' : '';
        div.innerHTML = lvTag +
            '<div class="card-name">' + card.name + '</div>' +
            '<div class="card-desc">' + card.desc + '</div>' +
            '<div class="card-desc" style="color:#ffcc00;margin-top:6px;">' + upgradeDesc + '</div>' +
            '<div class="card-rarity-tag ' + card.rarity + '">' +
                (card.rarity === 'common' ? 'æ™®é€š' : card.rarity === 'rare' ? 'ç¨€æœ‰' : 'å²è¯—') +
            '</div>';
        div.onclick = () => selectCard(card.id);
        container.appendChild(div);
    });
    overlay.classList.remove('hidden');
}

function selectCard(cardId) {
    const currentLv = player.cardLv(cardId);
    if (currentLv >= 5) return; // Lv.5 cap
    const newLv = currentLv + 1;
    player.cards.set(cardId, newLv);
    const card = CARD_DEFS.find(c => c.id === cardId);
    pickupTexts.push({
        x: player.x, y: player.y - 25,
        text: card.name + ' Lv.' + newLv,
        color: card.rarity === 'epic' ? '#aa44ff' : card.rarity === 'rare' ? '#4488ff' : '#ffffff',
        life: 2
    });
    spawnParticles(player.x, player.y, 8, '#ffcc00', 2);
    SFX.cardSelect();
    hideCardSelection();
}

function hideCardSelection() {
    cardSelectActive = false;
    document.getElementById('cardOverlay').classList.add('hidden');
}

document.getElementById('btnSkipCard').onclick = hideCardSelection;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ENEMY BASE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ENEMY_CFG = {
    drifter:  { hp: 1, speed: 2,   perception: 80,  size: 12, color: '#ff3355', score: 10, contactDmg: 10 },
    hunter:   { hp: 1, speed: 3,   perception: 180, size: 14, color: '#ff8800', score: 20, contactDmg: 15 },
    turret:   { hp: 7, speed: 0,   perception: 220, size: 18, color: '#aa44ff', score: 90, bulletDmg: 18 },
    sniper:   { hp: 3, speed: 0.5, perception: 9999,size: 13, color: '#ff2255', score: 70, bulletDmg: 22 },
    hive:     { hp: 15, speed: 0,   perception: 0,   size: 24, color: '#33ff66', score: 100, contactDmg: 0 },
    swarmling:{ hp: 1, speed: 3,   perception: 180, size: 6,  color: '#66ff88', score: 5,  contactDmg: 5 },
    phantom:  { hp: 4, speed: 2,   perception: 200, size: 14, color: '#bb77ff', score: 50, contactDmg: 14 },
    drainer:  { hp: 2, speed: 2,   perception: 150, size: 11, color: '#33aaff', score: 35, contactDmg: 0 },
};

class Enemy {
    constructor(type, x, y) {
        this.type = type;
        this.x = x; this.y = y;
        this.markedTimer = 0;
        this.markIntensity = 0;
        this.alive = true;
        this.state = 'patrol';
        this.lastKnownX = 0; this.lastKnownY = 0;
        this.stateTimer = 0;
        this.attackCooldown = 0;
        this.patrolAngle = rand(0, Math.PI * 2);
        const cfg = ENEMY_CFG[type];
        this.hp = cfg.hp;
        this.speed = cfg.speed;
        this.perceptionRange = cfg.perception;
        this.size = cfg.size;
        this.color = cfg.color;
        this.score = cfg.score;
        this.contactDmg = cfg.contactDmg || 10;
        this.tier = 0;          // evolution tier (0=normal, 1=enhanced, 2=elite, 3=berserk)
        this.tierDmgMul = 1;    // damage multiplier for ranged attacks
        this.hitFlash = 0;      // white flash timer on hit
    }
    update() {
        if (this.markedTimer > 0) this.markedTimer -= dt;
        if (this.markedTimer <= 0) this.markIntensity = 0;
        if (this.hitFlash > 0) this.hitFlash -= dt;

        const dToPlayer = dist(this.x, this.y, player.x, player.y);
        const hearsPlayer = this.canHearPlayer();
        // Proximity SENSE: 80px = can feel each other in the dark
        const sensesPlayer = dToPlayer < 80;
        const isMarked = this.markedTimer > 0;
        const hasVision = sensesPlayer || isMarked;

        // Swarmlings always lock on player (hive-mind link)
        if (this.type === 'swarmling') {
            this.state = 'alert';
            this.lastKnownX = player.x;
            this.lastKnownY = player.y;
            this.stateTimer = 0;
            this.doAlertMove(1.0);
            // Contact damage always (no vision needed)
            if (dToPlayer < this.size + player.radius + 3) {
                player.takeDamage(this.contactDmg);
            }
            // Wall collision
            for (const w of walls) {
                if (w instanceof FragileWall && !w.alive) continue;
                const push = pushCircleOutOfRect(this.x, this.y, this.size * 0.6, w.x, w.y, w.w, w.h);
                if (push) { this.x = push.x; this.y = push.y; }
            }
            return; // skip normal AI
        }

        switch (this.state) {
            case 'patrol':
                this.doPatrol();
                if (hearsPlayer) {
                    this.state = 'alert';
                    this.lastKnownX = playerNoiseX;
                    this.lastKnownY = playerNoiseY;
                    this.stateTimer = 0;
                } else if (sensesPlayer) {
                    this.state = 'alert';
                    this.lastKnownX = player.x;
                    this.lastKnownY = player.y;
                    this.stateTimer = 0;
                }
                break;
            case 'alert':
                if (sensesPlayer) {
                    // In proximity: real-time tracking, full speed
                    this.lastKnownX = player.x;
                    this.lastKnownY = player.y;
                    this.stateTimer = 0;
                    this.doAlertMove(1.0);
                } else if (isMarked) {
                    // Sonar-lit: rush toward last known
                    this.doAlertMove(0.8);
                    this.stateTimer += dt * 0.5;
                } else if (hearsPlayer) {
                    // Can hear but NOT see: slow groping
                    this.lastKnownX = playerNoiseX;
                    this.lastKnownY = playerNoiseY;
                    this.doAlertMove(0.3);
                    this.stateTimer += dt;
                } else {
                    // BLIND: confused wandering
                    this.patrolAngle += rand(-0.08, 0.08);
                    const bs = this.eSpeed();
                    this.x += Math.cos(this.patrolAngle) * bs * 0.15 * dt * 60;
                    this.y += Math.sin(this.patrolAngle) * bs * 0.15 * dt * 60;
                    this.stateTimer += dt * 3;
                }
                if (this.stateTimer > 2) {
                    this.state = 'search'; this.stateTimer = 0;
                }
                // Contact damage ONLY when enemy has vision (can see you)
                if (hasVision && dToPlayer < this.size + player.radius + 3) {
                    player.takeDamage(this.contactDmg);
                    this.stateTimer = 0;
                }
                break;
            case 'search':
                this.doSearch();
                if (hearsPlayer) {
                    this.state = 'alert';
                    this.lastKnownX = playerNoiseX;
                    this.lastKnownY = playerNoiseY;
                    this.stateTimer = 0;
                } else if (sensesPlayer) {
                    this.state = 'alert';
                    this.lastKnownX = player.x;
                    this.lastKnownY = player.y;
                    this.stateTimer = 0;
                }
                this.stateTimer += dt;
                if (this.stateTimer > 4) { this.state = 'patrol'; this.stateTimer = 0; }
                break;
        }
        // Wall collision for enemies
        for (const w of walls) {
            if (w instanceof FragileWall && !w.alive) continue;
            const push = pushCircleOutOfRect(this.x, this.y, this.size * 0.6, w.x, w.y, w.w, w.h);
            if (push) {
                this.x = push.x; this.y = push.y;
                this.patrolAngle += Math.PI * 0.5 + rand(-0.3, 0.3); // bounce off
            }
        }
        // Remove off-screen drifters
        const margin = 150;
        if (this.x < -margin || this.x > W + margin || this.y < -margin || this.y > H + margin) {
            if (this.type === 'drifter') this.alive = false;
        }
    }
    canHearPlayer() {
        if (playerNoiseRadius <= 0) return false;
        const d = dist(this.x, this.y, playerNoiseX, playerNoiseY);
        // Walls block sound propagation
        if (lineHitsWall(this.x, this.y, playerNoiseX, playerNoiseY)) return false;
        return d <= Math.min(playerNoiseRadius, this.perceptionRange);
    }
    // Effective speed: apply sonar slow if marked
    eSpeed() { return this.markedTimer > 0 ? this.speed * sonarSlowFactor : this.speed; }
    doPatrol() {
        const s = this.eSpeed();
        if (this.type === 'drifter') {
            this.x += Math.cos(this.patrolAngle) * s * dt * 60;
            this.y += Math.sin(this.patrolAngle) * s * dt * 60;
        } else {
            this.patrolAngle += rand(-0.02, 0.02);
            this.x += Math.cos(this.patrolAngle) * s * 0.3 * dt * 60;
            this.y += Math.sin(this.patrolAngle) * s * 0.3 * dt * 60;
        }
    }
    doAlertMove(speedMul) {
        const s = this.eSpeed();
        const angle = Math.atan2(this.lastKnownY - this.y, this.lastKnownX - this.x);
        this.x += Math.cos(angle) * s * speedMul * dt * 60;
        this.y += Math.sin(angle) * s * speedMul * dt * 60;
    }
    doSearch() {
        const s = this.eSpeed();
        this.patrolAngle += rand(-0.05, 0.05);
        this.x += Math.cos(this.patrolAngle) * s * 0.4 * dt * 60;
        this.y += Math.sin(this.patrolAngle) * s * 0.4 * dt * 60;
    }
    takeDamage(dmg) {
        if (!this.alive) return;
        this.hp -= dmg;
        this.markedTimer = Math.max(this.markedTimer, 0.5);
        spawnParticles(this.x, this.y, 3, this.color, 2);
        if (this.hp > 0) {
            // Hit but not killed â€” feedback for multi-HP enemies
            this.hitFlash = 0.12;
            SFX.enemyHit();
            // Floating damage number (preserve 1 decimal for non-integers)
            const dmgText = Number.isInteger(dmg) ? dmg : dmg.toFixed(1);
            pickupTexts.push({ x: this.x + rand(-8, 8), y: this.y - this.size - 5, text: '-' + dmgText, color: '#ffffff', life: 0.5 });
        }
        if (this.hp <= 0) {
            this.alive = false;
            // Apply double score if active
            const isDouble = player && player.scoreBonusTimer > 0;
            const actualScore = isDouble ? this.score * 2 : this.score;
            score += actualScore;
            spawnParticles(this.x, this.y, 5, this.color, 2);
            // Show kill score (doubled if bonus active)
            if (actualScore > 0) {
                const label = isDouble ? '+' + this.score + ' Ã—2' : '+' + actualScore;
                const color = isDouble ? '#ffee44' : '#ffcc00';
                pickupTexts.push({ x: this.x, y: this.y - 12, text: label, color: color, life: 0.8 });
            }
            // ALL enemies drop energy (100%)
            const dropAmt = { drifter: 10, hunter: 18, turret: 22, sniper: 30, hive: 35, swarmling: 3, phantom: 22, drainer: 15 };
            energyOrbs.push({ x: this.x, y: this.y, life: 10, amount: dropAmt[this.type] || 10 });
            SFX.hit();
            sessionStats.kills++;
            if (this.type === 'hive') sessionStats.hiveKills++;
            if (this.type === 'phantom') sessionStats.phantomKills++;
            if (this.type === 'drainer') sessionStats.drainerKills++;
        }
    }
    draw() {
        const dToPlayer = dist(this.x, this.y, player.x, player.y);

        // VISIBILITY: Two-layer system for smooth fog feeling
        // Inner zone (0-180px): clear visibility, exponential falloff
        // Outer zone (180-300px): ultra-faint shimmer (you can SENSE something is there)
        let proximityVis = 0;
        if (dToPlayer < 180) {
            const t = dToPlayer / 180;
            proximityVis = clamp(Math.pow(1 - t, 2) * 0.7, 0, 0.7);
        } else if (dToPlayer < 300) {
            // Ghost zone: barely perceptible shadow, flickers
            const t = (dToPlayer - 180) / 120;
            const flicker = 0.8 + Math.sin(performance.now() * 0.003 + this.x * 0.1) * 0.2;
            proximityVis = clamp((1 - t) * 0.06 * flicker, 0, 0.06);
        }

        const sonarVis = this.markedTimer > 0
            ? clamp(this.markedTimer / 0.5, 0, 1) * (this.markIntensity || 1)
            : 0;

        const vis = Math.max(proximityVis, sonarVis, 0.03);

        ctx.globalAlpha = vis;
        ctx.save();
        ctx.translate(this.x, this.y);

        // Tier glow for evolved enemies
        if (this.tier > 0 && vis > 0.05) {
            const tierColors = ['', 'rgba(255,220,60,', 'rgba(255,140,40,', 'rgba(255,50,30,'];
            const glowCol = tierColors[this.tier];
            const pulse = 0.3 + Math.sin(performance.now() * 0.004 + this.x * 0.1) * 0.15;
            const glowR = this.size + 4 + this.tier * 2;
            ctx.beginPath();
            ctx.arc(0, 0, glowR, 0, Math.PI * 2);
            ctx.strokeStyle = glowCol + (pulse * vis) + ')';
            ctx.lineWidth = 1 + this.tier * 0.5;
            ctx.stroke();
            ctx.fillStyle = glowCol + (pulse * vis * 0.12) + ')';
            ctx.fill();
            ctx.lineWidth = 1;
        }

        // Always use the enemy's own type color (never override to red)
        const isAggro = this.state === 'alert';
        ctx.fillStyle = this.color;
        // (glow removed for performance)

        // Alert indicator: small pulsing ring in enemy's OWN color
        if (isAggro && vis > 0.25) {
            const pulse = 0.3 + Math.sin(performance.now() * 0.008) * 0.15;
            ctx.strokeStyle = this.color;
            ctx.globalAlpha = vis * pulse;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, 0, this.size + 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = vis;
            ctx.lineWidth = 1;
        }

        const s = this.size;
        switch (this.type) {
            case 'drifter':
                ctx.fillRect(-s / 2, -s / 2, s, s);
                break;
            case 'hunter':
                ctx.beginPath();
                ctx.moveTo(0, -s); ctx.lineTo(s * 0.7, 0);
                ctx.lineTo(0, s); ctx.lineTo(-s * 0.7, 0);
                ctx.closePath(); ctx.fill();
                break;
            case 'turret':
                drawPolygon(ctx, 0, 0, s, 6); ctx.fill();
                break;
            case 'sniper':
                ctx.beginPath();
                ctx.moveTo(0, -s * 1.2); ctx.lineTo(s * 0.4, s * 0.6);
                ctx.lineTo(-s * 0.4, s * 0.6);
                ctx.closePath(); ctx.fill();
                break;
            case 'hive':
                // Large circle with inner segments
                ctx.beginPath(); ctx.arc(0, 0, s, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#227744'; ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const a = (Math.PI * 2 / 6) * i;
                    ctx.beginPath(); ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(a) * s, Math.sin(a) * s); ctx.stroke();
                }
                ctx.lineWidth = 1;
                break;
            case 'swarmling':
                // Tiny diamond
                ctx.beginPath();
                ctx.moveTo(0, -s); ctx.lineTo(s * 0.6, 0);
                ctx.lineTo(0, s); ctx.lineTo(-s * 0.6, 0);
                ctx.closePath(); ctx.fill();
                break;
            case 'phantom':
                // Wavy circle
                ctx.beginPath();
                for (let i = 0; i < 12; i++) {
                    const a = (Math.PI * 2 / 12) * i;
                    const wobble = s + Math.sin(performance.now() * 0.005 + i * 1.5) * 3;
                    const px = Math.cos(a) * wobble, py = Math.sin(a) * wobble;
                    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                }
                ctx.closePath(); ctx.fill();
                break;
            case 'drainer':
                // Swirl shape
                ctx.beginPath(); ctx.arc(0, 0, s, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#1166cc'; ctx.lineWidth = 1;
                const t = performance.now() * 0.003;
                ctx.beginPath(); ctx.arc(0, 0, s * 0.5, t, t + Math.PI * 1.5); ctx.stroke();
                ctx.lineWidth = 1;
                break;
            default:
                ctx.beginPath(); ctx.arc(0, 0, s, 0, Math.PI * 2); ctx.fill();
        }

        // Hit flash overlay â€” white flash when damaged but not killed
        if (this.hitFlash > 0) {
            const flashAlpha = (this.hitFlash / 0.12) * 0.7;
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = flashAlpha * vis;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath(); ctx.arc(0, 0, s + 2, 0, Math.PI * 2); ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = vis;
        }

        // State indicator
        if (vis > 0.2) {
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            if (this.state === 'search') {
                ctx.fillStyle = '#ffaa00';
                ctx.fillText('?', 0, -s - 5);
            }
        }

        ctx.restore();
        ctx.globalAlpha = 1;
    }
}

// Turret â€” stationary defense tower with visible detection zone
// ALWAYS shows a faint purple detection ring (220px) â€” player can see the danger zone
// When player enters zone â†’ locks on, rapid fire
// Every 6s: sends signal pulse alerting nearby enemies to player position
// SONAR JAM: sonar pulse hitting turret â†’ jammed 3s (no shooting, no signals, sparks)
// On kill â†’ BIG reward (30 HP + 30 energy + 80 score)
class Turret extends Enemy {
    constructor(x, y) {
        super('turret', x, y);
        this.detectRadius = 220;     // visible detection zone
        this.attackCooldown = 0.5;
        this.aimAngle = 0;
        this.signalTimer = 3;        // first signal after 3s
        this.signalInterval = 6;
        this.signalRadius = 0;
        this.signalActive = false;
        this.signalLineTimer = 0;    // visual line to player on signal
        this.signalTargetX = 0;
        this.signalTargetY = 0;
        this.jamTimer = 0;           // jammed by sonar
        this.sonarHits = 0;          // need 2 sonar hits to jam
        this.hitByPulses = new Set(); // track which pulse IDs already counted
        this.engaged = false;        // player in zone?
    }
    update() {
        if (this.markedTimer > 0) this.markedTimer -= dt;
        if (this.markedTimer <= 0) this.markIntensity = 0;
        if (this.hitFlash > 0) this.hitFlash -= dt;

        const dToPlayer = dist(this.x, this.y, player.x, player.y);
        this.engaged = dToPlayer < this.detectRadius;

        // Animate signal pulse ring
        if (this.signalActive) {
            this.signalRadius += 5 * dt * 60;
            if (this.signalRadius > 350) this.signalActive = false;
        }

        // Jammed: can't do anything, sparks visual
        if (this.jamTimer > 0) {
            this.jamTimer -= dt;
            return;
        }

        if (this.engaged) {
            // Player in detection zone â†’ lock on and fire
            this.state = 'alert';
            this.aimAngle = Math.atan2(player.y - this.y, player.x - this.x);
            this.lastKnownX = player.x;
            this.lastKnownY = player.y;

            this.attackCooldown -= dt;
            if (this.attackCooldown <= 0) {
                // Fire with slight inaccuracy
                const spread = rand(-0.1, 0.1);
                const b = new Bullet(this.x, this.y, this.aimAngle + spread, 7, 1, 'enemy');
                b.playerDmg = Math.ceil(ENEMY_CFG.turret.bulletDmg * (this.tierDmgMul || 1));
                b.markedTimer = 999; // turret bullets always visible
                b.color = '#cc66ff';  // purple to match turret
                bullets.push(b);
                this.attackCooldown = 0.45;
            }

            // (Signal/report functionality removed â€” turret is pure combat threat now)
        } else {
            this.state = 'patrol';
            this.attackCooldown = Math.max(this.attackCooldown, 0.5);
            this.signalTimer = Math.max(this.signalTimer, 2);
        }
    }
    // Sonar jam: called from handleCollisions
    sonarStun(pulseId) {
        if (pulseId && this.hitByPulses.has(pulseId)) return; // same pulse, ignore
        if (pulseId) this.hitByPulses.add(pulseId);
        this.sonarHits++;
        spawnParticles(this.x, this.y, 4, '#00f2ff', 1.5);
        if (this.sonarHits >= 2) {
            this.jamTimer = 3;
            this.sonarHits = 0;
            this.signalActive = false;
            spawnParticles(this.x, this.y, 6, '#00f2ff', 2);
        }
    }
    takeDamage(dmg) {
        this.hp -= dmg;
        this.markedTimer = Math.max(this.markedTimer, 0.5);
        spawnParticles(this.x, this.y, 6, this.color, 2);
        if (this.hp > 0) {
            this.hitFlash = 0.12;
            SFX.enemyHit();
            const dmgText = Number.isInteger(dmg) ? dmg : dmg.toFixed(1);
            pickupTexts.push({ x: this.x + rand(-8, 8), y: this.y - this.size - 5, text: '-' + dmgText, color: '#ffffff', life: 0.5 });
        }
        if (this.hp <= 0) {
            this.alive = false;
            const isDouble = player && player.scoreBonusTimer > 0;
            const baseScore = 80;
            const turretScore = isDouble ? baseScore * 2 : baseScore;
            score += turretScore;
            spawnParticles(this.x, this.y, 12, this.color, 3);
            spawnParticles(this.x, this.y, 8, '#ffcc00', 2);
            // BIG reward: HP + energy + energy orb
            player.hp = Math.min(player.maxHp, player.hp + 30);
            player.energy = Math.min(player.getMaxEnergy(), player.energy + 30);
            energyOrbs.push({ x: this.x, y: this.y, life: 12, amount: 25 });
            // Pickup text
            if (typeof pickupTexts !== 'undefined') {
                const tLabel = isDouble ? 'TURRET DOWN! +' + baseScore + ' Ã—2' : 'TURRET DOWN! +' + baseScore;
                pickupTexts.push({ x: this.x, y: this.y - 20, text: tLabel, color: isDouble ? '#ffee44' : '#ffcc00', life: 2 });
                pickupTexts.push({ x: this.x, y: this.y, text: 'HP+30  E+30', color: '#aa44ff', life: 1.8 });
            }
        }
    }
    draw() {
        // ALWAYS draw detection zone ring (visible in the dark!)
        // This is the key "fairness" visual â€” player can see the danger area
        const zonePulse = 0.12 + Math.sin(performance.now() * 0.002) * 0.04;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.detectRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(170,68,255,' + zonePulse + ')';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 8]);
        ctx.stroke();
        ctx.setLineDash([]);

        // When engaged: inner glow fill
        if (this.engaged && this.jamTimer <= 0) {
            ctx.fillStyle = 'rgba(170,68,255,0.02)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.detectRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Signal pulse ring (visible warning to player)
        if (this.signalActive) {
            const alpha = clamp(1 - this.signalRadius / 350, 0, 0.35);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.signalRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,100,255,' + alpha + ')';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.lineWidth = 1;
        }

        // Signal targeting line: shows turret reporting player position
        if (this.signalLineTimer > 0) {
            const t = this.signalLineTimer / 1.2;
            const blink = Math.sin(performance.now() * 0.02) > 0 ? 1 : 0.3;
            ctx.strokeStyle = 'rgba(255,100,255,' + (t * 0.4 * blink) + ')';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 6]);
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.signalTargetX, this.signalTargetY);
            ctx.stroke();
            ctx.setLineDash([]);
            // Pulsing crosshair at player's reported position
            const cr = 10 + (1 - t) * 5;
            ctx.strokeStyle = 'rgba(255,100,255,' + (t * 0.35) + ')';
            ctx.beginPath(); ctx.arc(this.signalTargetX, this.signalTargetY, cr, 0, Math.PI * 2); ctx.stroke();
            // Small cross
            ctx.beginPath();
            ctx.moveTo(this.signalTargetX - 5, this.signalTargetY);
            ctx.lineTo(this.signalTargetX + 5, this.signalTargetY);
            ctx.moveTo(this.signalTargetX, this.signalTargetY - 5);
            ctx.lineTo(this.signalTargetX, this.signalTargetY + 5);
            ctx.stroke();
            ctx.lineWidth = 1;
        }

        // Jammed: sparking effect
        if (this.jamTimer > 0) {
            ctx.fillStyle = '#00f2ff';
            for (let i = 0; i < 4; i++) {
                ctx.globalAlpha = 0.3 + Math.random() * 0.4;
                ctx.fillRect(this.x + rand(-12, 12), this.y + rand(-12, 12), 2, 2);
            }
            ctx.globalAlpha = 1;
            // "JAMMED" text
            ctx.fillStyle = '#00f2ff';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.globalAlpha = 0.6;
            ctx.fillText('JAM', this.x, this.y - this.size - 8);
            ctx.globalAlpha = 1;
        }

        // Normal enemy draw (hexagon shape)
        super.draw();
    }
    doPatrol() {}
}

// Sniper â€” long-range precision shooter with clear warning and multiple counterplay
// Hears ALL noise globally â†’ locks on â†’ 2.5s visible charge â†’ fires high-damage shot
// COUNTERPLAY:
//   1. DODGE: Laser line shows exact aim. Bullet is fast but narrow â€” sidestep it
//   2. SONAR HIT: Sonar pulse hitting sniper during charge â†’ stun 1.5s, reset charge
//   3. SHOOT IT: Bullet hit during charge â†’ flinch + reset charge
//   4. SILENT MOVE: Laser tracks noise position. Stop making noise + reposition = it misses
class Sniper extends Enemy {
    constructor(x, y) {
        super('sniper', x, y);
        this.charging = false;
        this.chargeTimer = 0;
        this.chargeMax = 1.5;       // seconds to charge
        this.targetX = 0;
        this.targetY = 0;
        this.stunTimer = 0;         // stunned after sonar/bullet hit
        this.cooldown = 0;          // post-fire cooldown before next charge
        this.flinching = false;
        this.hitByPulses = new Set(); // track which pulse IDs already counted
    }
    update() {
        if (this.markedTimer > 0) this.markedTimer -= dt;
        if (this.markedTimer <= 0) this.markIntensity = 0;
        if (this.hitFlash > 0) this.hitFlash -= dt;

        // Slow drift
        const ss = this.eSpeed();
        this.patrolAngle += rand(-0.008, 0.008);
        this.x += Math.cos(this.patrolAngle) * ss * dt * 60;
        this.y += Math.sin(this.patrolAngle) * ss * dt * 60;
        this.x = clamp(this.x, 40, W - 40);
        this.y = clamp(this.y, 40, H - 40);

        // Stun recovery
        if (this.stunTimer > 0) {
            this.stunTimer -= dt;
            this.charging = false;
            this.chargeTimer = 0;
            return;
        }

        // Post-fire cooldown
        if (this.cooldown > 0) {
            this.cooldown -= dt;
            return;
        }

        // Sniper hears ALL noise globally â€” walls don't block (long-range sensor)
        const hearsPlayer = playerNoiseRadius > 0;

        // Auto-scan timer: if no noise for a while, lock onto player's position
        if (!this.scanTimer) this.scanTimer = 0;
        this.scanTimer += dt;

        if (!this.charging) {
            // Listen for noise â†’ start charging immediately
            if (hearsPlayer) {
                this.charging = true;
                this.chargeTimer = 0;
                this.targetX = playerNoiseX;
                this.targetY = playerNoiseY;
                this.scanTimer = 0;
            } else if (this.scanTimer > 4) {
                // Auto-scan: no noise for 4s â†’ lock onto player area (inaccurate)
                this.charging = true;
                this.chargeTimer = 0;
                this.targetX = player.x + rand(-60, 60);
                this.targetY = player.y + rand(-60, 60);
                this.scanTimer = 0;
            }
        } else {
            // Charging: track noise (laser follows sound)
            if (hearsPlayer) {
                const trackSpeed = 0.05 + (this.chargeTimer / this.chargeMax) * 0.1;
                this.targetX = lerp(this.targetX, playerNoiseX, trackSpeed);
                this.targetY = lerp(this.targetY, playerNoiseY, trackSpeed);
                this.scanTimer = 0;
            } else {
                // No noise: aim drifts toward player slowly (imprecise but still threatening)
                this.targetX = lerp(this.targetX, player.x + rand(-40, 40), 0.01);
                this.targetY = lerp(this.targetY, player.y + rand(-40, 40), 0.01);
            }

            this.chargeTimer += dt;

            // FIRE when fully charged
            if (this.chargeTimer >= this.chargeMax) {
                const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                const b = new Bullet(this.x, this.y, angle, 18, 2, 'enemy');
                b.playerDmg = Math.ceil(ENEMY_CFG.sniper.bulletDmg * (this.tierDmgMul || 1));
                b.color = '#ff4444';
                b.radius = 4;
                b.maxRange = 1500; // sniper: extreme range
                b.markedTimer = 2; // sniper bullet is ALWAYS visible (tracer)
                bullets.push(b);
                spawnParticles(this.x, this.y, 6, '#ff2255', 2);
                this.charging = false;
                this.chargeTimer = 0;
                this.cooldown = 1.5; // 1.5s rest after firing
            }
        }
    }
    // Override takeDamage: getting hit during charge â†’ flinch and reset
    takeDamage(dmg) {
        super.takeDamage(dmg);
        if (this.charging) {
            this.charging = false;
            this.chargeTimer = 0;
            this.stunTimer = 1.0; // 1s stun from bullet hit
            this.flinching = true;
            spawnParticles(this.x, this.y, 8, '#ff2255', 2);
            setTimeout(() => { this.flinching = false; }, 500);
        }
    }
    // Sonar hit â†’ longer stun (called from handleCollisions)
    sonarStun(pulseId) {
        if (pulseId && this.hitByPulses.has(pulseId)) return; // same pulse, ignore
        if (pulseId) this.hitByPulses.add(pulseId);
        if (this.charging) {
            this.charging = false;
            this.chargeTimer = 0;
            this.stunTimer = 1.5; // 1.5s stun from sonar
            spawnParticles(this.x, this.y, 12, '#00f2ff', 3);
        }
    }
    draw() {
        // Laser warning line â€” visible even without sonar!
        // This is the primary "fairness" mechanism
        if (this.charging && this.chargeTimer > 0.3) {
            const progress = this.chargeTimer / this.chargeMax;
            // Line opacity and width increase as charge progresses
            const alpha = 0.1 + progress * 0.5;
            const width = progress > 0.8 ? 3 : (progress > 0.5 ? 2 : 1);

            // Pulsing at high charge
            const pulse = progress > 0.7 ? (1 + Math.sin(performance.now() * 0.02) * 0.3) : 1;

            ctx.strokeStyle = 'rgba(255,34,85,' + (alpha * pulse) + ')';
            ctx.lineWidth = width;
            ctx.setLineDash(progress > 0.8 ? [] : [6, 6]); // solid line when about to fire
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.targetX, this.targetY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.lineWidth = 1;

            // Crosshair at target
            if (progress > 0.4) {
                const cr = 8 + (1 - progress) * 12; // shrinks as charge completes
                ctx.strokeStyle = 'rgba(255,34,85,' + (alpha * 0.6) + ')';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.targetX, this.targetY, cr, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Stun visual: sparks
        if (this.stunTimer > 0) {
            ctx.fillStyle = '#00f2ff';
            ctx.globalAlpha = 0.5 + Math.random() * 0.3;
            for (let i = 0; i < 3; i++) {
                const ox = rand(-8, 8), oy = rand(-8, 8);
                ctx.fillRect(this.x + ox - 1, this.y + oy - 1, 2, 2);
            }
            ctx.globalAlpha = 1;
        }

        // Normal enemy draw
        super.draw();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HIVE â€” stationary spawner, releases swarmlings
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Hive extends Enemy {
    constructor(x, y) {
        super('hive', x, y);
        this.spawnTimer = 3.0;
        this.spawnInterval = 3.0;
        this.pulseAnim = 0;
    }
    update() {
        if (this.markedTimer > 0) this.markedTimer -= dt;
        if (this.markedTimer <= 0) this.markIntensity = 0;
        if (this.hitFlash > 0) this.hitFlash -= dt;
        // No movement, no perception â€” just spawns
        this.spawnTimer -= dt;
        // Cap swarmlings at 10 total on map
        let swarmCount = 0;
        for (const e of enemies) { if (e.type === 'swarmling' && e.alive) swarmCount++; }
        if (this.spawnTimer <= 0 && swarmCount < 10) {
            this.spawnTimer = this.spawnInterval;
            this.pulseAnim = 0.4;
            // Burst spawn: 2~3 swarmlings at once
            const burstCount = Math.min(10 - swarmCount, 2 + (Math.random() < 0.3 ? 1 : 0));
            for (let b = 0; b < burstCount; b++) {
                const a = rand(0, Math.PI * 2);
                const sx = this.x + Math.cos(a) * (20 + b * 8);
                const sy = this.y + Math.sin(a) * (20 + b * 8);
                const sw = new Enemy('swarmling', sx, sy);
                sw.state = 'alert';
                sw.lastKnownX = player.x + rand(-100, 100);
                sw.lastKnownY = player.y + rand(-100, 100);
                sw.stateTimer = 0;
                enemies.push(sw);
                spawnParticles(sx, sy, 3, '#66ff88', 1.5);
            }
        } else if (this.spawnTimer <= 0) {
            this.spawnTimer = 0.8; // retry soon
        }
        if (this.pulseAnim > 0) this.pulseAnim -= dt;
        // Wall collision
        for (const w of walls) {
            if (w instanceof FragileWall && !w.alive) continue;
            const push = pushCircleOutOfRect(this.x, this.y, this.size * 0.6, w.x, w.y, w.w, w.h);
            if (push) { this.x = push.x; this.y = push.y; }
        }
    }
    takeDamage(dmg) {
        super.takeDamage(dmg);
        if (this.hp <= 0) {
            // Kill all swarmlings when hive dies
            for (const e of enemies) {
                if (e.type === 'swarmling' && e.alive) {
                    const d = dist(e.x, e.y, this.x, this.y);
                    if (d < 300) { e.alive = false; spawnParticles(e.x, e.y, 4, '#66ff88', 2); score += 2; }
                }
            }
        }
    }
    draw() {
        // Pulsing spawn indicator
        if (this.pulseAnim > 0) {
            const r = this.size + (1 - this.pulseAnim / 0.4) * 15;
            ctx.globalAlpha = this.pulseAnim;
            ctx.strokeStyle = '#66ff88'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.stroke();
            ctx.globalAlpha = 1; ctx.lineWidth = 1;
        }
        super.draw();
    }
    doPatrol() {} // stationary
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PHANTOM â€” phases through walls, erratic movement
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Phantom extends Enemy {
    constructor(x, y) {
        super('phantom', x, y);
        this.phaseTimer = 0;
        this.driftAngle = rand(0, Math.PI * 2);
    }
    update() {
        if (this.markedTimer > 0) this.markedTimer -= dt;
        if (this.markedTimer <= 0) this.markIntensity = 0;
        if (this.hitFlash > 0) this.hitFlash -= dt;
        const dToPlayer = dist(this.x, this.y, player.x, player.y);
        // Phantom senses THROUGH walls â€” ignores lineHitsWall
        const sensesPlayer = dToPlayer < this.perceptionRange;
        const isMarked = this.markedTimer > 0;
        this.phaseTimer += dt;
        if (sensesPlayer || isMarked) {
            // Erratic pursuit â€” drifts toward player with random oscillation
            const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
            this.driftAngle = lerp(this.driftAngle, toPlayer, 0.04);
            this.driftAngle += Math.sin(this.phaseTimer * 3) * 0.08;
            const ps = this.eSpeed();
            this.x += Math.cos(this.driftAngle) * ps * dt * 60;
            this.y += Math.sin(this.driftAngle) * ps * dt * 60;
            this.state = 'alert';
            // Contact damage
            if (dToPlayer < this.size + player.radius + 3) {
                player.takeDamage(this.contactDmg);
            }
        } else {
            // Random drift
            this.driftAngle += rand(-0.05, 0.05);
            const pd = this.eSpeed();
            this.x += Math.cos(this.driftAngle) * pd * 0.3 * dt * 60;
            this.y += Math.sin(this.driftAngle) * pd * 0.3 * dt * 60;
            this.state = 'patrol';
        }
        // Phantom does NOT collide with walls â€” phases through
        this.x = clamp(this.x, -50, W + 50);
        this.y = clamp(this.y, -50, H + 50);
    }
    draw() {
        // Override visibility: Phantom is always ghostly transparent
        const origDraw = Enemy.prototype.draw;
        const self = this;
        // Temporarily boost markedTimer for drawing so it's somewhat visible
        const savedMark = this.markedTimer;
        const savedIntensity = this.markIntensity;
        // Phantom: ghostly flicker effect â€” always slightly visible
        const flicker = 0.3 + Math.sin(performance.now() * 0.008 + this.x * 0.05) * 0.15;
        if (this.markedTimer > 0) {
            this.markIntensity = (this.markIntensity || 1) * flicker;
        }
        super.draw();
        this.markedTimer = savedMark;
        this.markIntensity = savedIntensity;
    }
    doPatrol() {}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DRAINER â€” drains player energy on proximity
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Drainer extends Enemy {
    constructor(x, y) {
        super('drainer', x, y);
        this.drainActive = false;
    }
    update() {
        if (this.markedTimer > 0) this.markedTimer -= dt;
        if (this.markedTimer <= 0) this.markIntensity = 0;
        if (this.hitFlash > 0) this.hitFlash -= dt;
        const dToPlayer = dist(this.x, this.y, player.x, player.y);
        const hearsPlayer = this.canHearPlayer();
        const sensesPlayer = dToPlayer < 80;
        const isMarked = this.markedTimer > 0;
        // Drainer is especially attracted to sonar
        if (hearsPlayer || sensesPlayer || isMarked) {
            this.state = 'alert';
            this.lastKnownX = hearsPlayer ? playerNoiseX : player.x;
            this.lastKnownY = hearsPlayer ? playerNoiseY : player.y;
            this.doAlertMove(hearsPlayer ? 1.2 : 0.8); // faster when hearing sonar
        } else {
            this.state = 'patrol';
            this.doPatrol();
        }
        // Drain energy when close
        this.drainActive = dToPlayer < 80;
        if (this.drainActive) {
            player.energy = Math.max(0, player.energy - 8 * dt); // 8/s drain
            // Visual: pull energy particles toward drainer
            if (Math.random() < 0.3) {
                const a = rand(0, Math.PI * 2);
                const px = player.x + Math.cos(a) * 15;
                const py = player.y + Math.sin(a) * 15;
                particles.push(new Particle(px, py, '#33aaff', 1));
            }
        }
        // Wall collision
        for (const w of walls) {
            if (w instanceof FragileWall && !w.alive) continue;
            const push = pushCircleOutOfRect(this.x, this.y, this.size * 0.6, w.x, w.y, w.w, w.h);
            if (push) { this.x = push.x; this.y = push.y; this.patrolAngle += Math.PI * 0.5; }
        }
        const margin = 150;
        if (this.x < -margin || this.x > W + margin || this.y < -margin || this.y > H + margin) this.alive = false;
    }
    draw() {
        // Swirl effect when draining
        if (this.drainActive) {
            const t = performance.now() * 0.003;
            ctx.strokeStyle = 'rgba(51,170,255,0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                const a = t + (Math.PI * 2 / 3) * i;
                const r1 = 20, r2 = 6;
                ctx.beginPath();
                ctx.moveTo(this.x + Math.cos(a) * r1, this.y + Math.sin(a) * r1);
                ctx.lineTo(this.x + Math.cos(a + 0.5) * r2, this.y + Math.sin(a + 0.5) * r2);
                ctx.stroke();
            }
            ctx.lineWidth = 1;
        }
        super.draw();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOSS BASE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let activeBoss = null;
let bossWarningTimer = 0; // pre-spawn warning

class Boss {
    constructor(type, hp, x, y) {
        this.type = type;
        this.x = x; this.y = y;
        this.hp = hp; this.maxHp = hp;
        this.alive = true;
        this.markedTimer = 0;
        this.markIntensity = 0;
        this.size = 30;
        this.score = 200;
        this.attackTimer = 0;
        this.phaseTimer = 0;
        this.hitFlash = 0;
    }
    takeDamage(dmg) {
        if (!this.alive) return; // already dead, ignore further hits this frame
        this.hp -= dmg;
        this.markedTimer = Math.max(this.markedTimer, 1);
        this.hitFlash = 0.1;
        SFX.enemyHit();
        spawnParticles(this.x, this.y, 3, '#ffffff', 2);
        if (this.hp <= 0) {
            this.alive = false;
            activeBoss = null;
            const isDouble = player && player.scoreBonusTimer > 0;
            const actualScore = isDouble ? this.score * 2 : this.score;
            score += actualScore;
            spawnParticles(this.x, this.y, 20, '#ffcc00', 4);
            spawnParticles(this.x, this.y, 10, '#ffffff', 3);
            // Boss drop: premium card selection (4 choices) + HP + energy
            showCardSelection(4);
            player.hp = Math.min(player.maxHp, player.hp + 30);
            player.energy = Math.min(player.getMaxEnergy(), player.energy + 50);
            energyOrbs.push({ x: this.x, y: this.y, life: 15, amount: 40 });
            const bossLabel = isDouble ? 'BOSS DOWN! +' + this.score + ' Ã—2' : 'BOSS DOWN! +' + this.score;
            pickupTexts.push({ x: this.x, y: this.y - 30, text: bossLabel, color: isDouble ? '#ffee44' : '#ffcc00', life: 3 });
            pickupTexts.push({ x: this.x, y: this.y, text: 'HP+30 ENERGY+50', color: '#66ffcc', life: 2.5 });
            SFX.bossDead(); SFX.explosion();
            sessionStats.bossKills++;
            sessionStats.bossTypesKilled.add(this.type);
        }
    }
    update() { if (this.hitFlash > 0) this.hitFlash -= dt; }
    draw() {}
    drawHPBar() {
        // Hit flash overlay for boss
        if (this.hitFlash > 0) {
            const flashAlpha = (this.hitFlash / 0.1) * 0.5;
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = flashAlpha;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size + 3, 0, Math.PI * 2); ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
        }
        const w = 80, h = 5;
        const pct = this.hp / this.maxHp;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(this.x - w / 2, this.y - this.size - 14, w, h);
        ctx.fillStyle = pct > 0.5 ? '#ff4466' : '#ff0033';
        ctx.fillRect(this.x - w / 2, this.y - this.size - 14, w * pct, h);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.strokeRect(this.x - w / 2, this.y - this.size - 14, w, h);
    }
}

// Boss 1: Core Satellite (90s) â€” rotating octagon with 4 core points
class BossSatellite extends Boss {
    constructor() {
        super('satellite', 12, W / 2 + rand(-100, 100), rand(60, H - 60));
        this.score = 200;
        this.size = 35;
        this.angle = 0;
        this.attackTimer = 3;
    }
    update() {
        super.update();
        if (this.markedTimer > 0) this.markedTimer -= dt;
        this.phaseTimer += dt;
        this.angle += 0.8 * dt;
        // Slow chase
        const a = Math.atan2(player.y - this.y, player.x - this.x);
        this.x += Math.cos(a) * 1 * dt * 60;
        this.y += Math.sin(a) * 1 * dt * 60;
        this.x = clamp(this.x, 50, W - 50);
        this.y = clamp(this.y, 50, H - 50);
        // Cross-pattern bullets every 3s
        this.attackTimer -= dt;
        if (this.attackTimer <= 0) {
            this.attackTimer = 2.8;
            for (let i = 0; i < 4; i++) {
                const ba = this.angle + (Math.PI / 2) * i;
                const b = new Bullet(this.x, this.y, ba, 5, 1, 'enemy');
                b.playerDmg = 12;
                b.markedTimer = 999; b.color = '#ff6688'; b.radius = 4;
                bullets.push(b);
            }
            spawnParticles(this.x, this.y, 6, '#ff6688', 2);
        }
    }
    draw() {
        // Always faintly visible (boss fairness)
        const sonarVis = this.markedTimer > 0 ? clamp(this.markedTimer / 0.5, 0, 1) : 0;
        const vis = Math.max(0.15, sonarVis);
        ctx.globalAlpha = vis;
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        // Octagon body
        ctx.strokeStyle = '#ff4466'; ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const a = (Math.PI * 2 / 8) * i;
            const px = Math.cos(a) * this.size, py = Math.sin(a) * this.size;
            i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath(); ctx.stroke();
        // 4 core points
        for (let i = 0; i < 4; i++) {
            const a = (Math.PI / 2) * i;
            const cx = Math.cos(a) * this.size * 0.6, cy = Math.sin(a) * this.size * 0.6;
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI * 2); ctx.fill();
        }
        ctx.restore(); ctx.globalAlpha = 1; ctx.lineWidth = 1;
        this.drawHPBar();
    }
}

// Boss 2: Split Mother (180s) â€” splits into drifters when damaged
class BossSplitMother extends Boss {
    constructor() {
        super('splitmom', 25, rand(100, W - 100), rand(100, H - 100));
        this.score = 300;
        this.size = 40;
        this.attackTimer = 3;
        this.lastSplitHp = 25;
        this.pathAngle = rand(0, Math.PI * 2);
    }
    update() {
        super.update();
        if (this.markedTimer > 0) this.markedTimer -= dt;
        this.phaseTimer += dt;
        // Chase player (not just drift)
        const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
        this.pathAngle = lerp(this.pathAngle, toPlayer, 0.03);
        this.x += Math.cos(this.pathAngle) * 2.2 * dt * 60;
        this.y += Math.sin(this.pathAngle) * 2.2 * dt * 60;
        this.x = clamp(this.x, 60, W - 60); this.y = clamp(this.y, 60, H - 60);
        // Burst of 8 bullets
        this.attackTimer -= dt;
        if (this.attackTimer <= 0) {
            this.attackTimer = 2.5;
            for (let i = 0; i < 8; i++) {
                const ba = (Math.PI * 2 / 8) * i + this.phaseTimer;
                const b = new Bullet(this.x, this.y, ba, 4.5, 1, 'enemy');
                b.playerDmg = 12; b.markedTimer = 999; b.color = '#ff4444'; b.radius = 3;
                bullets.push(b);
            }
        }
    }
    takeDamage(dmg) {
        const hpBefore = this.hp;
        super.takeDamage(dmg);
        // Split: spawn hunters every 5 HP lost (cap at 8 split-hunters on screen)
        const threshold = 5;
        if (Math.floor(hpBefore / threshold) > Math.floor(Math.max(this.hp, 0) / threshold)) {
            let hunterCount = 0;
            for (const e of enemies) { if (e.type === 'hunter' && e.alive) hunterCount++; }
            const spawnCount = Math.min(3, Math.max(0, 15 - hunterCount));
            for (let i = 0; i < spawnCount; i++) {
                const a = rand(0, Math.PI * 2);
                const e = new Enemy('hunter', this.x + Math.cos(a) * 40, this.y + Math.sin(a) * 40);
                e.state = 'alert'; e.lastKnownX = player.x; e.lastKnownY = player.y;
                e.markedTimer = 3;
                e.markIntensity = 1;
                enemies.push(e);
            }
            spawnParticles(this.x, this.y, 8, '#ff3355', 3);
            pickupTexts.push({ x: this.x, y: this.y - 20, text: 'âš  åˆ†è£‚!', color: '#ff3355', life: 2 });
        }
    }
    draw() {
        const sonarVis = this.markedTimer > 0 ? clamp(this.markedTimer / 0.5, 0, 1) : 0;
        const vis = Math.max(0.15, sonarVis);
        const pulse = 0.8 + Math.sin(performance.now() * 0.004) * 0.2;
        ctx.globalAlpha = vis * pulse;
        ctx.fillStyle = '#ff3355';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        // Inner pulsing ring
        ctx.strokeStyle = '#ff6688'; ctx.lineWidth = 2;
        const inner = this.size * 0.6 + Math.sin(performance.now() * 0.006) * 4;
        ctx.beginPath(); ctx.arc(this.x, this.y, inner, 0, Math.PI * 2); ctx.stroke();
        ctx.globalAlpha = 1; ctx.lineWidth = 1;
        this.drawHPBar();
    }
}

// Boss 3: Signal Jammer (360s) â€” reduces sonar effectiveness nearby
class BossJammer extends Boss {
    constructor() {
        super('jammer', 28, rand(100, W - 100), rand(100, H - 100));
        this.score = 500;
        this.size = 38;
        this.jamRadius = 180;
        this.attackTimer = 3;
        this.vertices = [];
        for (let i = 0; i < 7; i++) {
            this.vertices.push({ a: (Math.PI * 2 / 7) * i, r: this.size + rand(-8, 8) });
        }
    }
    update() {
        super.update();
        if (this.markedTimer > 0) this.markedTimer -= dt;
        this.phaseTimer += dt;
        // Chase player
        const a = Math.atan2(player.y - this.y, player.x - this.x);
        this.x += Math.cos(a) * 1.5 * dt * 60;
        this.y += Math.sin(a) * 1.5 * dt * 60;
        this.x = clamp(this.x, 50, W - 50); this.y = clamp(this.y, 50, H - 50);
        // 3-bullet spread toward player
        this.attackTimer -= dt;
        if (this.attackTimer <= 0) {
            this.attackTimer = 2.5;
            const toP = Math.atan2(player.y - this.y, player.x - this.x);
            for (let i = -1; i <= 1; i++) {
                const b = new Bullet(this.x, this.y, toP + i * 0.2, 6, 1, 'enemy');
                b.playerDmg = 15; b.markedTimer = 999; b.color = '#cccccc'; b.radius = 4;
                bullets.push(b);
            }
        }
    }
    draw() {
        const jamAlpha = 0.04 + Math.sin(performance.now() * 0.003) * 0.02;
        ctx.fillStyle = 'rgba(200,200,220,' + jamAlpha + ')';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.jamRadius, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = 'rgba(200,200,220,0.08)';
        ctx.setLineDash([3, 5]);
        ctx.beginPath(); ctx.arc(this.x, this.y, this.jamRadius, 0, Math.PI * 2); ctx.stroke();
        ctx.setLineDash([]);
        const sonarVis = this.markedTimer > 0 ? clamp(this.markedTimer / 0.5, 0, 1) : 0;
        const vis = Math.max(0.18, sonarVis);
        ctx.globalAlpha = vis;
        ctx.fillStyle = '#ddeeff';
        ctx.beginPath();
        for (let i = 0; i < this.vertices.length; i++) {
            const v = this.vertices[i];
            const jitter = Math.sin(performance.now() * 0.01 + i) * 2;
            const px = this.x + Math.cos(v.a + this.phaseTimer * 0.3) * (v.r + jitter);
            const py = this.y + Math.sin(v.a + this.phaseTimer * 0.3) * (v.r + jitter);
            i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath(); ctx.fill();
        ctx.globalAlpha = 1;
        for (let i = 0; i < 3; i++) {
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = 0.3 + Math.random() * 0.3;
            ctx.fillRect(this.x + rand(-this.size, this.size), this.y + rand(-this.size, this.size), 2, 2);
        }
        ctx.globalAlpha = 1;
        this.drawHPBar();
    }
}

// Boss 4: Phantom Lord (480s) â€” phases through walls, teleports, summons phantoms
class BossPhantomLord extends Boss {
    constructor() {
        super('phantomlord', 35, rand(100, W - 100), rand(100, H - 100));
        this.score = 600;
        this.size = 36;
        this.attackTimer = 2.5;
        this.teleportTimer = 8;
        this.summonTimer = 12;
        this.driftAngle = rand(0, Math.PI * 2);
        this.teleportFlash = 0;
    }
    update() {
        super.update();
        if (this.markedTimer > 0) this.markedTimer -= dt;
        this.phaseTimer += dt;
        if (this.teleportFlash > 0) this.teleportFlash -= dt;
        // Erratic pursuit â€” drifts toward player (phases through walls)
        const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
        this.driftAngle = lerp(this.driftAngle, toPlayer, 0.03);
        this.driftAngle += Math.sin(this.phaseTimer * 2) * 0.06;
        this.x += Math.cos(this.driftAngle) * 1.8 * dt * 60;
        this.y += Math.sin(this.driftAngle) * 1.8 * dt * 60;
        this.x = clamp(this.x, 30, W - 30); this.y = clamp(this.y, 30, H - 30);
        // Teleport every 8s
        this.teleportTimer -= dt;
        if (this.teleportTimer <= 0) {
            this.teleportTimer = 7 + rand(0, 3);
            spawnParticles(this.x, this.y, 10, '#bb77ff', 4);
            const a = rand(0, Math.PI * 2);
            const d = rand(120, 250);
            this.x = clamp(player.x + Math.cos(a) * d, 50, W - 50);
            this.y = clamp(player.y + Math.sin(a) * d, 50, H - 50);
            this.teleportFlash = 0.5;
            spawnParticles(this.x, this.y, 10, '#bb77ff', 4);
        }
        // Fire 6 homing bolts every 2.5s
        this.attackTimer -= dt;
        if (this.attackTimer <= 0) {
            this.attackTimer = 2.5;
            const toP = Math.atan2(player.y - this.y, player.x - this.x);
            for (let i = 0; i < 6; i++) {
                const ba = toP + (Math.PI * 2 / 6) * i;
                const b = new Bullet(this.x, this.y, ba, 4, 1, 'enemy');
                b.playerDmg = 12; b.markedTimer = 999; b.color = '#bb77ff'; b.radius = 3;
                bullets.push(b);
            }
            spawnParticles(this.x, this.y, 6, '#9955dd', 2);
        }
        // Summon 2 phantoms every 12s
        this.summonTimer -= dt;
        if (this.summonTimer <= 0) {
            this.summonTimer = 11 + rand(0, 3);
            let pCount = 0;
            for (const e of enemies) { if (e.type === 'phantom' && e.alive) pCount++; }
            const spawn = Math.min(2, Math.max(0, 6 - pCount));
            for (let i = 0; i < spawn; i++) {
                const a = rand(0, Math.PI * 2);
                const px = this.x + Math.cos(a) * 50;
                const py = this.y + Math.sin(a) * 50;
                const ph = new Phantom(px, py);
                ph.markedTimer = 2; ph.markIntensity = 1;
                enemies.push(ph);
            }
            if (spawn > 0) pickupTexts.push({ x: this.x, y: this.y - 20, text: 'âš  å¹»å½±å¬å”¤!', color: '#bb77ff', life: 2 });
        }
    }
    draw() {
        const sonarVis = this.markedTimer > 0 ? clamp(this.markedTimer / 0.5, 0, 1) : 0;
        const vis = Math.max(0.15, sonarVis);
        const flash = this.teleportFlash > 0 ? 0.6 : 0;
        ctx.globalAlpha = Math.min(1, vis + flash);
        // Ethereal body â€” double circle with wavy edges
        ctx.save(); ctx.translate(this.x, this.y);
        ctx.fillStyle = '#9944cc';
        ctx.beginPath();
        for (let i = 0; i < 12; i++) {
            const a = (Math.PI * 2 / 12) * i;
            const wobble = this.size + Math.sin(this.phaseTimer * 3 + i * 1.2) * 5;
            const px = Math.cos(a) * wobble, py = Math.sin(a) * wobble;
            i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath(); ctx.fill();
        // Inner eye
        ctx.fillStyle = '#ffaaff';
        ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#440066';
        ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
        ctx.globalAlpha = 1;
        this.drawHPBar();
    }
}

// Boss 5: Overload Core (600s) â€” final boss, spiral bullets + phase 2 frenzy
class BossOverload extends Boss {
    constructor() {
        super('overload', 50, W / 2, H / 2);
        this.score = 1000;
        this.size = 45;
        this.attackTimer = 0.4;
        this.spiralAngle = 0;
        this.summonTimer = 15;
        this.phase2 = false;
    }
    update() {
        super.update();
        if (this.markedTimer > 0) this.markedTimer -= dt;
        this.phaseTimer += dt;
        // Enter phase 2 below 50% HP
        if (!this.phase2 && this.hp <= this.maxHp * 0.5) {
            this.phase2 = true;
            pickupTexts.push({ x: this.x, y: this.y - 30, text: 'âš  è¿‡è½½æ¨¡å¼!', color: '#ff0000', life: 3 });
            spawnParticles(this.x, this.y, 20, '#ff4400', 5);
        }
        const spd = this.phase2 ? 2.2 : 1.2;
        const toP = Math.atan2(player.y - this.y, player.x - this.x);
        this.x += Math.cos(toP) * spd * dt * 60;
        this.y += Math.sin(toP) * spd * dt * 60;
        this.x = clamp(this.x, 50, W - 50); this.y = clamp(this.y, 50, H - 50);
        // Spiral bullet pattern
        const fireRate = this.phase2 ? 0.15 : 0.35;
        this.attackTimer -= dt;
        if (this.attackTimer <= 0) {
            this.attackTimer = fireRate;
            this.spiralAngle += this.phase2 ? 0.7 : 0.5;
            const arms = this.phase2 ? 4 : 2;
            for (let i = 0; i < arms; i++) {
                const ba = this.spiralAngle + (Math.PI * 2 / arms) * i;
                const b = new Bullet(this.x, this.y, ba, this.phase2 ? 5.5 : 4, 1, 'enemy');
                b.playerDmg = this.phase2 ? 18 : 12;
                b.markedTimer = 999;
                b.color = this.phase2 ? '#ff2200' : '#ff6633';
                b.radius = this.phase2 ? 4 : 3;
                bullets.push(b);
            }
        }
        // Summon mixed enemies
        this.summonTimer -= dt;
        if (this.summonTimer <= 0) {
            this.summonTimer = this.phase2 ? 8 : 14;
            const types = ['hunter', 'drifter', 'phantom'];
            const count = this.phase2 ? 3 : 2;
            for (let i = 0; i < count; i++) {
                const type = types[Math.floor(rand(0, types.length))];
                const a = rand(0, Math.PI * 2);
                const ex = clamp(this.x + Math.cos(a) * 80, 30, W - 30);
                const ey = clamp(this.y + Math.sin(a) * 80, 30, H - 30);
                let e;
                if (type === 'phantom') e = new Phantom(ex, ey);
                else e = new Enemy(type, ex, ey);
                e.state = 'alert'; e.lastKnownX = player.x; e.lastKnownY = player.y;
                e.markedTimer = 2; e.markIntensity = 1;
                enemies.push(e);
            }
            pickupTexts.push({ x: this.x, y: this.y - 20, text: 'âš  å¢æ´!', color: '#ff4400', life: 1.5 });
        }
    }
    draw() {
        const sonarVis = this.markedTimer > 0 ? clamp(this.markedTimer / 0.5, 0, 1) : 0;
        const vis = Math.max(0.2, sonarVis);
        ctx.globalAlpha = vis;
        // Pulsing core
        const pulse = 0.8 + Math.sin(performance.now() * 0.005) * 0.2;
        const coreColor = this.phase2 ? '#ff2200' : '#ff6633';
        ctx.fillStyle = coreColor;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2); ctx.fill();
        // Electric arcs
        ctx.strokeStyle = this.phase2 ? '#ffaa00' : '#ffcc66';
        ctx.lineWidth = 2;
        for (let i = 0; i < (this.phase2 ? 8 : 5); i++) {
            const a = (Math.PI * 2 / (this.phase2 ? 8 : 5)) * i + this.phaseTimer * 1.5;
            const r1 = this.size * 0.6;
            const r2 = this.size * (1.2 + Math.sin(performance.now() * 0.008 + i) * 0.3);
            ctx.beginPath();
            ctx.moveTo(this.x + Math.cos(a) * r1, this.y + Math.sin(a) * r1);
            // Jagged arc
            const mid = a + 0.15;
            ctx.lineTo(this.x + Math.cos(mid) * (r1 + r2) * 0.55, this.y + Math.sin(mid) * (r1 + r2) * 0.55);
            ctx.lineTo(this.x + Math.cos(a) * r2, this.y + Math.sin(a) * r2);
            ctx.stroke();
        }
        ctx.lineWidth = 1;
        // Inner white core
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = vis * (0.5 + Math.sin(performance.now() * 0.01) * 0.3);
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 0.3, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
        this.drawHPBar();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FRAGILE & REFLECTIVE WALLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class FragileWall extends Wall {
    constructor(x, y, w, h) {
        super(x, y, w, h);
        this.wallHp = 2;
        this.alive = true;
    }
    takeDamage() {
        this.wallHp--;
        spawnParticles(this.x + this.w / 2, this.y + this.h / 2, 6, '#aa8866', 2);
        if (this.wallHp <= 0) {
            this.alive = false;
            spawnParticles(this.x + this.w / 2, this.y + this.h / 2, 8, '#aa8866', 2);
            SFX.explosion();
            sessionStats.wallsBroken++;
        }
    }
    draw() {
        if (!this.alive) return;
        // Cracked texture
        const crack = 1 - this.wallHp / 2;
        ctx.fillStyle = 'rgba(40,30,25,' + (0.8 + crack * 0.15) + ')';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.strokeStyle = 'rgba(160,120,80,' + (0.15 + crack * 0.15) + ')';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(this.x + 0.5, this.y + 0.5, this.w - 1, this.h - 1);
        // Crack lines
        if (crack > 0) {
            ctx.strokeStyle = 'rgba(120,90,60,' + (crack * 0.4) + ')';
            ctx.lineWidth = 1;
            const cx = this.x + this.w / 2, cy = this.y + this.h / 2;
            for (let i = 0; i < Math.ceil(crack * 4); i++) {
                const a = (Math.PI * 2 / 4) * i + 0.3;
                ctx.beginPath(); ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(a) * this.w * 0.5, cy + Math.sin(a) * this.h * 0.5);
                ctx.stroke();
            }
        }
        ctx.lineWidth = 1;
    }
}

class ReflectWall extends Wall {
    constructor(x, y, w, h) {
        super(x, y, w, h);
    }
    draw() {
        // Metallic mirror surface
        ctx.fillStyle = 'rgba(45,50,60,0.95)';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        // Shiny metallic border
        const shimmer = 0.2 + Math.sin(performance.now() * 0.002 + this.glowPhase) * 0.08;
        ctx.strokeStyle = 'rgba(180,200,220,' + shimmer + ')';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x + 0.5, this.y + 0.5, this.w - 1, this.h - 1);
        // Reflective diagonal lines
        ctx.strokeStyle = 'rgba(160,180,200,0.06)';
        ctx.lineWidth = 1;
        for (let d = -this.w; d < this.w + this.h; d += 12) {
            ctx.beginPath();
            ctx.moveTo(this.x + d, this.y);
            ctx.lineTo(this.x + d - this.h, this.y + this.h);
            ctx.stroke();
        }
        ctx.lineWidth = 1;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PARTICLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Particle {
    constructor(x, y, color, speed) {
        this.x = x; this.y = y; this.color = color;
        const a = rand(0, Math.PI * 2);
        this.vx = Math.cos(a) * rand(0.5, speed);
        this.vy = Math.sin(a) * rand(0.5, speed);
        this.life = 1;
        this.decay = rand(0.035, 0.07); // faster fade
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.vx *= 0.97; this.vy *= 0.97;
        this.life -= this.decay;
    }
    draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - 1.5, this.y - 1.5, 3, 3);
        ctx.globalAlpha = 1;
    }
}
// In-place array cleanup (avoids creating new arrays each frame)
function purgeArray(arr, keep) {
    let w = 0;
    for (let r = 0; r < arr.length; r++) {
        if (keep(arr[r])) arr[w++] = arr[r];
    }
    arr.length = w;
}

const MAX_PARTICLES = 200;
const MAX_BULLETS = 120;
function spawnParticles(x, y, count, color, speed) {
    const room = MAX_PARTICLES - particles.length;
    const n = Math.min(count, room);
    for (let i = 0; i < n; i++) particles.push(new Particle(x, y, color, speed));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NOISE & HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function emitNoise(x, y, radius) {
    if (radius > playerNoiseRadius) {
        playerNoiseRadius = radius;
        playerNoiseX = x; playerNoiseY = y;
    }
}
function drawPolygon(ctx, cx, cy, r, sides) {
    ctx.beginPath();
    for (let i = 0; i < sides; i++) {
        const a = (Math.PI * 2 / sides) * i - Math.PI / 2;
        const px = cx + Math.cos(a) * r;
        const py = cy + Math.sin(a) * r;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPAWNING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let spawnTimers = {};
let crateTimer = 0;

function spawnEnemy(type) {
    const side = Math.floor(rand(0, 4));
    let x, y;
    const buf = 60;
    if (side === 0) { x = rand(0, W); y = -buf; }
    else if (side === 1) { x = W + buf; y = rand(0, H); }
    else if (side === 2) { x = rand(0, W); y = H + buf; }
    else { x = -buf; y = rand(0, H); }
    const tx = W / 2 + rand(-200, 200);
    const ty = H / 2 + rand(-200, 200);
    let e;
    if (type === 'turret') {
        let tx2, ty2, tries = 0;
        do { tx2 = rand(100, W - 100); ty2 = rand(100, H - 100); tries++; }
        while (pointInWall(tx2, ty2) && tries < 20);
        e = new Turret(tx2, ty2);
    } else if (type === 'sniper') {
        let sx2, sy2, tries = 0;
        do { sx2 = rand(80, W - 80); sy2 = rand(80, H - 80); tries++; }
        while (pointInWall(sx2, sy2) && tries < 20);
        e = new Sniper(sx2, sy2);
    } else if (type === 'hive') {
        let hx, hy, tries = 0;
        do { hx = rand(100, W - 100); hy = rand(100, H - 100); tries++; }
        while (pointInWall(hx, hy) && tries < 20);
        e = new Hive(hx, hy);
    } else if (type === 'phantom') {
        e = new Phantom(x, y);
    } else if (type === 'drainer') {
        e = new Drainer(x, y);
        e.patrolAngle = Math.atan2(ty - y, tx - x);
    } else {
        e = new Enemy(type, x, y);
        e.patrolAngle = Math.atan2(ty - y, tx - x);
    }
    // â”€â”€ Enemy evolution tier based on game time â”€â”€
    const tier = gameTime < 186 ? 0 : (gameTime < 335 ? 1 : (gameTime < 463 ? 2 : 3));
    e.tier = tier;
    if (tier > 0) {
        const hpMul  = [1, 1.3, 1.75, 2.3][tier];
        const spdMul = [1, 1.1, 1.2, 1.3][tier];
        const dmgMul = [1, 1.15, 1.3, 1.5][tier];
        e.hp = Math.ceil(e.hp * hpMul);
        e.speed *= spdMul;
        e.contactDmg = Math.ceil(e.contactDmg * dmgMul);
        e.tierDmgMul = dmgMul;
        e.size *= (1 + tier * 0.04); // slightly larger
        e.score = Math.ceil(e.score * (1 + tier * 0.2)); // more score reward
    }
    enemies.push(e);
}

function spawnSupplyCrate() {
    let x, y, tries = 0;
    do {
        x = rand(80, W - 80); y = rand(80, H - 80);
        tries++;
    } while (pointInWall(x, y) && tries < 20);
    supplyCrates.push(new SupplyCrate(x, y));
}

function spawnCardCrate() {
    let x, y, tries = 0;
    do {
        x = rand(100, W - 100); y = rand(100, H - 100);
        tries++;
    } while (pointInWall(x, y) && tries < 20);
    cardCrates.push(new CardCrate(x, y));
}

let wallPhase = 0; // track which wall phase we've generated
let shownEvolveTier = 0; // track evolution tier notifications
let breathEvents = [false, false, false]; // track 83s section-break events per loop
// Boss schedule (must persist across frames)
// Boss schedule â€” aligned to music beats -2s for latency (212s loop)
const BOSS_SCHEDULE = [
    { time: 123, cls: 'satellite',    label: 'âš  BOSS: æ ¸å¿ƒå«æ˜Ÿ',    color: '#ff4466',  spawned: false },  // L1:125s beat
    { time: 251, cls: 'splitmom',     label: 'âš  BOSS: åˆ†è£‚æ¯ä½“',    color: '#ff3355',  spawned: false },  // L2:41s beat
    { time: 398, cls: 'jammer',       label: 'âš  BOSS: ä¿¡å·å¹²æ‰°è€…',  color: '#ddeeff',  spawned: false },  // L2:188s beat
    { time: 484, cls: 'phantomlord',  label: 'âš  BOSS: å¹½çµé¢†ä¸»',    color: '#bb77ff',  spawned: false },  // L3:62s beat
    { time: 610, cls: 'overload',     label: 'âš  FINAL BOSS: è¿‡è½½æ ¸å¿ƒ', color: '#ff2200', spawned: false }, // L3:188s beat
];
function createBoss(type) {
    switch (type) {
        case 'satellite': return new BossSatellite();
        case 'splitmom': return new BossSplitMother();
        case 'jammer': return new BossJammer();
        case 'phantomlord': return new BossPhantomLord();
        case 'overload': return new BossOverload();
    }
}

function updateSpawning() {
    const t = gameTime;
    // â”€â”€ 10-minute gentle difficulty ramp â”€â”€
    const diffMul = 1 + t / 300;

    // â”€â”€ Count enemies by type for caps â”€â”€
    const eCounts = {};
    for (const e of enemies) { eCounts[e.type] = (eCounts[e.type] || 0) + 1; }
    const totalEnemies = enemies.length;

    // â”€â”€ Global enemy cap: grows slowly over 10 min â”€â”€
    const globalCap = Math.min(22 + Math.floor(t / 75) * 4, 55);

    // â”€â”€ Enemy evolution tier notifications (aligned to music beats -2s) â”€â”€
    const curTier = t < 186 ? 0 : (t < 335 ? 1 : (t < 463 ? 2 : 3));
    if (curTier > shownEvolveTier) {
        shownEvolveTier = curTier;
        const msgs = ['', 'âš  æ•Œäººå¼€å§‹å¼ºåŒ–ï¼', 'âš  ç²¾è‹±æ•Œäººå‡ºç°ï¼', 'âš  æ•Œäººè¿›å…¥ç‹‚æš´çŠ¶æ€ï¼'];
        const cols = ['', '#ffdd44', '#ff8833', '#ff3322'];
        pickupTexts.push({ x: W / 2, y: H / 2 - 80, text: msgs[curTier], color: cols[curTier], life: 3.5 });
    }

    // â”€â”€ Wall phase transitions (aligned to music beats -2s) â”€â”€
    if (wallPhase === 0 && t >= 60) {           // L1:62s accent -2
        wallPhase = 1;
        generateWalls(1);
        pickupTexts.push({ x: W / 2, y: H / 2 - 40, text: 'âš  ç¯å¢ƒå˜åŒ–ï¼šå¢™ä½“å‡ºç°', color: '#00b8dc', life: 3 });
    } else if (wallPhase === 1 && t >= 210) {   // L2:0s accent -2
        wallPhase = 2;
        generateWalls(2);
        pickupTexts.push({ x: W / 2, y: H / 2 - 40, text: 'âš  åœ°å½¢å¤æ‚åŒ–ï¼šè„†å¼±å¢™å‡ºç°', color: '#ff8800', life: 3 });
    } else if (wallPhase === 2 && t >= 355) {   // L2:145s accent -2
        wallPhase = 3;
        generateWalls(3);
        pickupTexts.push({ x: W / 2, y: H / 2 - 40, text: 'âš  å¤æ‚åœ°å½¢ï¼šåå°„å¢™å‡ºç°', color: '#bbddff', life: 3 });
    }

    // â”€â”€ Resupply events (filling gaps between major beats) â”€â”€
    // L1:104s accent -2 = 102s â€” supplies before Boss 1 at 123
    if (!breathEvents[0] && t >= 102 && t < 105) {
        breathEvents[0] = true;
        for (let i = 0; i < 3; i++) spawnSupplyCrate();
        spawnCardCrate();
        pickupTexts.push({ x: W / 2, y: H / 2 - 40, text: 'ğŸ“¦ è¡¥ç»™ç©ºæŠ•', color: '#66ffcc', life: 2.5 });
    }
    // L2:83s = 295s -2 = 293s â€” mid-game resupply before phantom wave at 314
    if (!breathEvents[1] && t >= 293 && t < 296) {
        breathEvents[1] = true;
        for (let i = 0; i < 3; i++) spawnSupplyCrate();
        spawnCardCrate();
        pickupTexts.push({ x: W / 2, y: H / 2 - 40, text: 'ğŸ“¦ ç´§æ€¥è¡¥ç»™', color: '#66ffcc', life: 2.5 });
    }
    // L3:83s = 507s -2 = 505s â€” late-game full resupply before final stretch
    if (!breathEvents[2] && t >= 505 && t < 508) {
        breathEvents[2] = true;
        for (let i = 0; i < 4; i++) spawnSupplyCrate();
        spawnCardCrate();
        pickupTexts.push({ x: W / 2, y: H / 2 - 40, text: 'ğŸ“¦ æœ€ç»ˆè¡¥ç»™', color: '#ffcc00', life: 2.5 });
    }

    // â”€â”€ Spawn helpers: respect caps â”€â”€
    const canSpawn = (type, cap) => totalEnemies < globalCap && (eCounts[type] || 0) < cap;

    // â”€â”€ PHASE 1 (0-39s): Drifters only â€” learn basics â”€â”€
    spawnTimers.drifter = (spawnTimers.drifter || 0) - dt;
    if (spawnTimers.drifter <= 0 && canSpawn('drifter', 12)) {
        const drifterBatch = t < 60 ? 1 : (t < 210 ? 2 : 2);
        for (let i = 0; i < drifterBatch; i++) { if (canSpawn('drifter', 12)) spawnEnemy('drifter'); }
        spawnTimers.drifter = Math.max(1.5, 3.2 / diffMul);
    } else if (spawnTimers.drifter <= 0) {
        spawnTimers.drifter = 1.8;
    }

    // â”€â”€ PHASE 2 (39s+): Hunters join â€” L1:41s accent -2 â”€â”€
    if (t > 39) {
        spawnTimers.hunter = (spawnTimers.hunter || 0) - dt;
        if (spawnTimers.hunter <= 0 && canSpawn('hunter', 6)) {
            spawnEnemy('hunter');
            spawnTimers.hunter = Math.max(3.5, 8 / diffMul);
        } else if (spawnTimers.hunter <= 0) spawnTimers.hunter = 3.5;
    }

    // â”€â”€ PHASE 3 (81s+): Turrets join â€” L1:83s æ®µè½ -2 (é™æ€æ•Œäººé…å®‰é™æ®µè½) â”€â”€
    if (t > 81) {
        spawnTimers.turret = (spawnTimers.turret || 0) - dt;
        if (spawnTimers.turret <= 0 && canSpawn('turret', 3)) {
            spawnEnemy('turret');
            spawnTimers.turret = Math.max(14, 28 / diffMul);
        } else if (spawnTimers.turret <= 0) spawnTimers.turret = 10;
    }

    // â”€â”€ PHASE 4 (143s+): Snipers join â€” L1:145s accent -2 â”€â”€
    if (t > 143) {
        spawnTimers.sniper = (spawnTimers.sniper || 0) - dt;
        if (spawnTimers.sniper <= 0 && canSpawn('sniper', 2)) {
            spawnEnemy('sniper');
            spawnTimers.sniper = Math.max(12, 25 / diffMul);
        } else if (spawnTimers.sniper <= 0) spawnTimers.sniper = 10;
    }

    // â”€â”€ PHASE 5 (230s+): Hives join â€” L2:20s accent -2 â”€â”€
    if (t > 230) {
        spawnTimers.hive = (spawnTimers.hive || 0) - dt;
        if (spawnTimers.hive <= 0 && canSpawn('hive', 2)) {
            spawnEnemy('hive');
            spawnTimers.hive = Math.max(20, 38 / diffMul);
        } else if (spawnTimers.hive <= 0) spawnTimers.hive = 14;
    }

    // â”€â”€ PHASE 6 (314s+): Phantoms join â€” L2:104s accent -2 â”€â”€
    if (t > 314) {
        spawnTimers.phantom = (spawnTimers.phantom || 0) - dt;
        if (spawnTimers.phantom <= 0 && canSpawn('phantom', 3)) {
            spawnEnemy('phantom');
            spawnTimers.phantom = Math.max(10, 22 / diffMul);
        } else if (spawnTimers.phantom <= 0) spawnTimers.phantom = 8;
    }

    // â”€â”€ PHASE 7 (422s+): Drainers join â€” L3:0s accent -2 â”€â”€
    if (t > 422) {
        spawnTimers.drainer = (spawnTimers.drainer || 0) - dt;
        if (spawnTimers.drainer <= 0 && canSpawn('drainer', 2)) {
            spawnEnemy('drainer');
            spawnTimers.drainer = Math.max(12, 26 / diffMul);
        } else if (spawnTimers.drainer <= 0) spawnTimers.drainer = 10;
    }

    // â”€â”€ Boss spawning â€” 5 unique bosses across 10 minutes â”€â”€
    if (!activeBoss && bossWarningTimer <= 0) {
        for (const entry of BOSS_SCHEDULE) {
            if (!entry.spawned && t >= entry.time && t < entry.time + 3) {
                entry.spawned = true;
                SFX.bossWarn();
                activeBoss = createBoss(entry.cls);
                pickupTexts.push({ x: W / 2, y: H / 2 - 60, text: entry.label, color: entry.color, life: 3 });
                bossWarningTimer = 5;
                break;
            }
        }
        // After all 5 bosses: cycle harder versions every 120s
        const allSpawned = BOSS_SCHEDULE.every(e => e.spawned);
        if (allSpawned && t > 738) {   // L3+: 740s accent -2
            const cycleT = t - 738;
            const cycleIdx = Math.floor(cycleT / 120);
            const nextTime = 738 + cycleIdx * 120;
            if (t >= nextTime && t < nextTime + 3) {
                SFX.bossWarn();
                const types = ['satellite', 'splitmom', 'jammer', 'phantomlord', 'overload'];
                activeBoss = createBoss(types[cycleIdx % types.length]);
                const hpScale = 1 + (cycleIdx + 1) * 0.3;
                activeBoss.hp = Math.round(activeBoss.hp * hpScale);
                activeBoss.maxHp = activeBoss.hp;
                pickupTexts.push({ x: W / 2, y: H / 2 - 60, text: 'âš  BOSS: å¼ºåŒ–å›å½’!', color: '#ffcc00', life: 3 });
                bossWarningTimer = 5;
            }
        }
    }
    if (bossWarningTimer > 0) bossWarningTimer -= dt;

    // Supply crates: spawn faster as game progresses (8-14s early â†’ 4-7s late)
    crateTimer -= dt;
    const crateMaxOnScreen = gameTime > 180 ? 7 : 5;
    if (crateTimer <= 0 && supplyCrates.length < crateMaxOnScreen) {
        spawnSupplyCrate();
        const timeFactor = clamp(gameTime / 300, 0, 1); // ramps over 5 minutes
        const minInterval = lerp(8, 4, timeFactor);
        const maxInterval = lerp(14, 7, timeFactor);
        crateTimer = rand(minInterval, maxInterval);
    }

    // Card crates: scales faster as game progresses, max 3 on screen
    cardCrateTimer -= dt;
    if (cardCrateTimer <= 0 && cardCrates.length < 3) {
        spawnCardCrate();
        // Dynamic interval: 18-24s early â†’ 10-14s by 180s
        const cardTimeFactor = clamp(t / 180, 0, 1);
        const cardMinI = lerp(18, 10, cardTimeFactor);
        const cardMaxI = lerp(24, 14, cardTimeFactor);
        cardCrateTimer = rand(cardMinI, cardMaxI);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  COLLISION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function handleCollisions() {
    // Energy harvest: diminishing per kill (cap ~23)
    const harvestLv = player.cardLv('energyharvest');
    const harvestAmt = Math.round(26 * harvestLv / (harvestLv + 2.5));
    // Echo extend: mark time multiplier (cap ~+175%)
    const echoLv = player.cardLv('echo');
    const echoMul = 1 + 2 * echoLv / (echoLv + 2.5);
    // Player bullets vs enemies (with distance pre-check)
    for (let b of bullets) {
        if (!b.alive || b.owner !== 'player') continue;
        for (let e of enemies) {
            if (!e.alive) continue;
            // Quick reject: skip if clearly too far (Manhattan distance)
            if (Math.abs(b.x - e.x) > 40 || Math.abs(b.y - e.y) > 40) continue;
            if (dist(b.x, b.y, e.x, e.y) < e.size + b.radius) {
                const wasAlive = e.hp > 0;
                e.takeDamage(b.damage);
                spawnParticles(b.x, b.y, 2, '#fff', 2);
                // Reflect kill tracking
                if (wasAlive && e.hp <= 0 && b.reflected) sessionStats.reflectKills++;
                // Energy harvest: gain energy on kill
                if (wasAlive && e.hp <= 0 && harvestLv > 0) {
                    player.energy = Math.min(player.getMaxEnergy(), player.energy + harvestAmt);
                    spawnParticles(e.x, e.y, 6, '#00ffaa', 2);
                }
                // Pierce: bullet continues through enemies
                if (b.pierceLeft > 0) {
                    b.pierceLeft--;
                    b.damage = Math.max(1, b.damage); // keep at least 1 damage
                } else {
                    b.alive = false;
                    break;
                }
            }
        }
    }

    // Player bullets vs Boss
    if (activeBoss && activeBoss.alive) {
        for (let b of bullets) {
            if (!activeBoss || !activeBoss.alive) break; // boss died this frame, stop
            if (!b.alive || b.owner !== 'player') continue;
            if (dist(b.x, b.y, activeBoss.x, activeBoss.y) < activeBoss.size + b.radius) {
                activeBoss.takeDamage(b.damage);
                spawnParticles(b.x, b.y, 1, '#ffcc00', 1.5);
                if (b.pierceLeft > 0) { b.pierceLeft--; } else { b.alive = false; }
            }
        }
    }

    // Enemy bullets vs player (with per-bullet damage)
    for (let b of bullets) {
        if (!b.alive || b.owner !== 'enemy') continue;
        if (Math.abs(b.x - player.x) > 20 || Math.abs(b.y - player.y) > 20) continue;
        if (dist(b.x, b.y, player.x, player.y) < player.radius + b.radius) {
            player.takeDamage(b.playerDmg || 15);
            b.alive = false;
        }
    }

    // Bullets vs special walls only (fragile/reflect); normal wall collision in Bullet.update()
    for (let b of bullets) {
        if (!b.alive) continue;
        for (let w of specialWalls) {
            if (b.x < w.x - 10 || b.x > w.x + w.w + 10 || b.y < w.y - 10 || b.y > w.y + w.h + 10) continue;
            if (w instanceof FragileWall) {
                if (!w.alive) continue;
                if (b.x > w.x && b.x < w.x + w.w && b.y > w.y && b.y < w.y + w.h) {
                    w.takeDamage(); // both player AND enemy bullets can break fragile walls
                    b.alive = false; break;
                }
            } else if (w instanceof ReflectWall) {
                if (b.x > w.x && b.x < w.x + w.w && b.y > w.y && b.y < w.y + w.h) {
                    // Determine which face was hit and reflect
                    const cx = w.x + w.w / 2, cy = w.y + w.h / 2;
                    const dx = b.x - cx, dy = b.y - cy;
                    if (Math.abs(dx / w.w) > Math.abs(dy / w.h)) {
                        b.vx = -b.vx; b.x += b.vx * 2;
                    } else {
                        b.vy = -b.vy; b.y += b.vy * 2;
                    }
                    // Change ownership on reflect â€” enemyâ†”player swap
                    if (b.owner === 'enemy') { b.owner = 'player'; b.color = '#00ddff'; b.damage = 1; b.reflected = true; }
                    else if (b.owner === 'player') { b.owner = 'enemy'; b.color = '#ff8844'; b.playerDmg = 8; }
                    spawnParticles(b.x, b.y, 4, '#bbddff', 2);
                }
            }
            // Normal walls already handled in Bullet.update() with pointInWall
        }
    }

    // NOTE: Enemy contact damage is handled inside each enemy's update()

    // Pulse -> mark enemies, bullets, supply crates, AND card crates
    // Jammer debuff: halve mark time if near jammer boss
    const jammerActive = activeBoss && activeBoss.alive && activeBoss.type === 'jammer';
    for (let p of pulses) {
        if (!p.alive) continue;
        // Sonar vs Boss
        if (activeBoss && activeBoss.alive && p.hitsPoint(activeBoss.x, activeBoss.y)) {
            if (!lineHitsWall(p.x, p.y, activeBoss.x, activeBoss.y)) {
                const d = dist(p.x, p.y, activeBoss.x, activeBoss.y);
                const ratio = 1 - clamp(d / p.maxRadius, 0, 1);
                activeBoss.markedTimer = Math.max(activeBoss.markedTimer, 1.0 + ratio * 2.0);
            }
        }
        for (let e of enemies) {
            if (!e.alive) continue;
            if (p.hitsPoint(e.x, e.y)) {
                // Phantom ignores walls for sonar but still needs to be hit by pulse ring
                if (e.type !== 'phantom' && lineHitsWall(p.x, p.y, e.x, e.y)) continue;
                const d = dist(p.x, p.y, e.x, e.y);
                const ratio = 1 - clamp(d / p.maxRadius, 0, 1);
                let markTime = (0.4 + ratio * 2.0) * echoMul;
                // Phantom: shorter mark time (1s)
                if (e.type === 'phantom') markTime = Math.min(markTime, 1.0);
                // Jammer debuff: halve if near jammer
                if (jammerActive && dist(e.x, e.y, activeBoss.x, activeBoss.y) < activeBoss.jamRadius) {
                    markTime *= 0.5;
                }
                e.markedTimer = Math.max(e.markedTimer, markTime);
                e.markIntensity = Math.max(e.markIntensity || 0, 0.25 + ratio * 0.75);
                if (e.state === 'patrol' || e.state === 'search') {
                    e.state = 'alert';
                    e.lastKnownX = p.x;
                    e.lastKnownY = p.y;
                    e.stateTimer = 0;
                }
                if (e.sonarStun) e.sonarStun(p.id);
            }
        }
        for (let b of bullets) {
            if (!b.alive || b.owner !== 'enemy') continue;
            if (p.hitsPoint(b.x, b.y)) {
                const d = dist(p.x, p.y, b.x, b.y);
                const ratio = 1 - clamp(d / p.maxRadius, 0, 1);
                b.markedTimer = Math.max(b.markedTimer, 0.3 + ratio * 1.5);
            }
        }
        // Pulse reveals supply crates
        for (let c of supplyCrates) {
            if (!c.alive) continue;
            if (p.hitsPoint(c.x, c.y)) {
                if (lineHitsWall(p.x, p.y, c.x, c.y)) continue;
                const d = dist(p.x, p.y, c.x, c.y);
                const ratio = 1 - clamp(d / p.maxRadius, 0, 1);
                c.markedTimer = Math.max(c.markedTimer, 1.5 + ratio * 3.0);
            }
        }
        // Pulse reveals card crates
        for (let c of cardCrates) {
            if (!c.alive) continue;
            if (p.hitsPoint(c.x, c.y)) {
                if (lineHitsWall(p.x, p.y, c.x, c.y)) continue;
                const d = dist(p.x, p.y, c.x, c.y);
                const ratio = 1 - clamp(d / p.maxRadius, 0, 1);
                c.markedTimer = Math.max(c.markedTimer, 2.0 + ratio * 4.0);
            }
        }
    }

    // Energy orb cap: mark oldest as dead if too many
    if (energyOrbs.length > 60) {
        for (let i = 0; i < energyOrbs.length - 60; i++) energyOrbs[i].life = 0;
    }
    // Energy orb pickup
    for (let i = 0; i < energyOrbs.length; i++) {
        const orb = energyOrbs[i];
        orb.life -= dt;
        if (orb.life <= 0) continue;
        const d = dist(orb.x, orb.y, player.x, player.y);
        if (d < 60 && d > 0) {
            const pull = 3 * dt * 60;
            const ang = Math.atan2(player.y - orb.y, player.x - orb.x);
            orb.x += Math.cos(ang) * pull;
            orb.y += Math.sin(ang) * pull;
        }
        if (d < 20) {
            player.energy = Math.min(player.getMaxEnergy(), player.energy + orb.amount);
            spawnParticles(orb.x, orb.y, 8, '#00aaff', 2);
            orb.life = 0;
        }
    }
    // Cleanup dead orbs (every 10 frames)
    if (frameCount % 10 === 0) purgeArray(energyOrbs, o => o.life > 0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HUD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateHUD() {
    $scoreVal.textContent = score;
    $bestVal.textContent = best;

    // HP bar
    const hpPct = (player.hp / player.maxHp) * 100;
    $hpBar.style.width = hpPct + '%';
    if (hpPct < 30) {
        $hpBar.style.background = 'linear-gradient(90deg, #ff0033, #ff3355)';
    } else if (hpPct < 60) {
        $hpBar.style.background = 'linear-gradient(90deg, #ff6644, #ff8866)';
    } else {
        $hpBar.style.background = 'linear-gradient(90deg, #ff2266, #ff6688)';
    }

    // Shield indicator on HP bar
    if (player.shieldActive) {
        $hpBar.style.border = '1px solid rgba(102,204,255,0.8)';
        $hpBar.style.boxShadow = '0 0 6px rgba(102,204,255,0.5)';
    } else {
        $hpBar.style.border = 'none';
        $hpBar.style.boxShadow = 'none';
    }

    // Energy bar
    const pct = (player.energy / player.getMaxEnergy()) * 100;
    $eBar.style.width = pct + '%';
    if (player.energy < player.sonarCost) {
        $eBar.style.background = 'linear-gradient(90deg, #ff0055, #ff4444)';
        $eBar.style.boxShadow = '0 0 8px #ff0055';
    } else {
        $eBar.style.background = 'linear-gradient(90deg, #00f2ff, #00c3ff)';
        $eBar.style.boxShadow = '0 0 8px #00f2ff';
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loop(now) {
    if (!playing) return;
    if (gamePaused) return; // Stop loop when paused
    dt = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;

    // Pause everything except drawing during card selection
    if (!cardSelectActive) {
        gameTime += dt;
        frameCount++;
        if (frameCount % 6 === 0) score++;
        playerNoiseRadius = Math.max(0, playerNoiseRadius - 400 * dt);
        // Track no-damage time
        sessionStats.noDmgTimer += dt;
        sessionStats.maxNoDmgTime = Math.max(sessionStats.maxNoDmgTime, sessionStats.noDmgTimer);
        // Track no-sonar time
        sessionStats.noSonarTimer += dt;
        sessionStats.maxNoSonarTime = Math.max(sessionStats.maxNoSonarTime, sessionStats.noSonarTimer);
        // Track evolution tier reached
        const curTierStat = gameTime < 186 ? 0 : (gameTime < 335 ? 1 : (gameTime < 463 ? 2 : 3));
        sessionStats.tierReached = Math.max(sessionStats.tierReached, curTierStat);
        // Periodic achievement check (every 3s)
        achieveCheckTimer = (achieveCheckTimer || 0) + dt;
        if (achieveCheckTimer >= 3) { achieveCheckTimer = 0; checkAchievements(); }

        player.update();
        updateSpawning();
        // Sonar Slow: compute speed multiplier for marked enemies
        const ssLv = player.cardLv('sonarslow');
        sonarSlowFactor = ssLv > 0 ? 1 - [0, 0.25, 0.40, 0.50, 0.58, 0.65][ssLv] : 1;
        pulses.forEach(p => p.update());
        bullets.forEach(b => b.update());
        enemies.forEach(e => e.update());
        supplyCrates.forEach(c => c.update());
        cardCrates.forEach(c => c.update());
        particles.forEach(p => p.update());
        handleCollisions();

        // Boss update
        if (activeBoss && activeBoss.alive) activeBoss.update();
        if (activeBoss && !activeBoss.alive) activeBoss = null;

        // Cleanup: bullets every frame (high turnover), others every 3 frames
        purgeArray(bullets, b => b.alive);
        if (frameCount % 3 === 0) {
            purgeArray(pulses, p => p.alive);
            purgeArray(enemies, e => e.alive);
            purgeArray(supplyCrates, c => c.alive);
            purgeArray(cardCrates, c => c.alive);
            purgeArray(particles, p => p.life > 0);
            purgeArray(walls, w => !(w instanceof FragileWall) || w.alive);
            // Bullet cap: kill oldest enemy bullets when over limit
            if (bullets.length > MAX_BULLETS) {
                let excess = bullets.length - MAX_BULLETS;
                for (let i = 0; i < bullets.length && excess > 0; i++) {
                    if (bullets[i].owner === 'enemy') { bullets[i].alive = false; excess--; }
                }
            }
        }
    }

    // Draw
    ctx.save();
    if (shakeTimer > 0) {
        shakeTimer -= dt;
        ctx.translate(rand(-4, 4), rand(-4, 4));
    }
    ctx.fillStyle = 'rgba(5,5,5,0.4)';
    ctx.fillRect(0, 0, W, H);
    if (damageFlash > 0) {
        damageFlash -= dt;
        ctx.fillStyle = 'rgba(255,0,50,' + (damageFlash * 0.3) + ')';
        ctx.fillRect(0, 0, W, H);
    }

    // Walls
    walls.forEach(w => w.draw());

    // Energy orbs
    const orbFlicker = 0.5 + Math.sin(now * 0.005) * 0.3;
    ctx.fillStyle = '#00aaff';
    for (const orb of energyOrbs) {
        if (orb.life <= 0) continue;
        ctx.globalAlpha = orbFlicker;
        ctx.beginPath(); ctx.arc(orb.x, orb.y, 5, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    supplyCrates.forEach(c => c.draw());
    cardCrates.forEach(c => c.draw());
    enemies.forEach(e => e.draw());
    if (activeBoss && activeBoss.alive) activeBoss.draw();
    bullets.forEach(b => b.draw());
    pulses.forEach(p => p.draw());
    player.draw();
    particles.forEach(p => p.draw());

    // Boss HP bar at top of screen
    if (activeBoss && activeBoss.alive) {
        const bw = 300, bh = 8;
        const bx = W / 2 - bw / 2, by = 40;
        const pct = activeBoss.hp / activeBoss.maxHp;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(bx - 2, by - 2, bw + 4, bh + 4);
        ctx.fillStyle = pct > 0.5 ? '#ff4466' : pct > 0.25 ? '#ff8800' : '#ff0033';
        ctx.fillRect(bx, by, bw * pct, bh);
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.strokeRect(bx - 2, by - 2, bw + 4, bh + 4);
        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Orbitron, monospace';
        ctx.textAlign = 'center';
        const bossNames = { satellite: 'æ ¸å¿ƒå«æ˜Ÿ', splitmom: 'åˆ†è£‚æ¯ä½“', jammer: 'ä¿¡å·å¹²æ‰°è€…' };
        ctx.fillText((bossNames[activeBoss.type] || 'BOSS') + ' HP: ' + activeBoss.hp + '/' + activeBoss.maxHp, W / 2, by - 6);
        ctx.textAlign = 'left';
    }

    // Floating pickup text
    for (let i = pickupTexts.length - 1; i >= 0; i--) {
        const pt = pickupTexts[i];
        pt.life -= dt;
        pt.y -= 30 * dt;
        if (pt.life <= 0) { pickupTexts.splice(i, 1); continue; }
        const a = clamp(pt.life / 0.5, 0, 1);
        ctx.globalAlpha = a;
        ctx.fillStyle = pt.color;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.font = 'bold 14px Orbitron, monospace';
        ctx.textAlign = 'center';
        ctx.strokeText(pt.text, pt.x, pt.y);
        ctx.fillText(pt.text, pt.x, pt.y);
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
    }

    // Card inventory display (top right)
    if (player.cards.size > 0) {
        ctx.textAlign = 'right';
        ctx.font = '10px Orbitron, monospace';
        let ci = 0;
        for (const [id, lv] of player.cards) {
            const card = CARD_MAP[id];
            if (!card) continue;
            const yy = 20 + ci * 16;
            ctx.fillStyle = card.rarity === 'epic' ? '#aa44ff' : card.rarity === 'rare' ? '#4488ff' : '#888';
            ctx.globalAlpha = 0.7;
            ctx.fillText(card.name + ' Lv.' + lv, W - 16, yy);
            ci++;
        }
        ctx.globalAlpha = 1;
        ctx.textAlign = 'left';
    }

    ctx.restore();
    updateHUD();
    requestAnimationFrame(loop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SONAR INPUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
addEventListener('mousedown', e => {
    if (!playing || cardSelectActive) return;
    if (e.button === 2) player.pulse();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PAUSE SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let gamePaused = false;
const ENEMY_GUIDE = [
    { type: 'drifter', name: 'æ¼‚æµè€…', desc: 'éšæœºæ¸¸è¡ï¼Œæ¥è§¦ä¼¤å®³', color: '#ff3355' },
    { type: 'hunter', name: 'çŒæ‰‹', desc: 'å¬å£°è¿½è¸ªï¼Œé«˜é€Ÿå†²æ’', color: '#ff8800' },
    { type: 'turret', name: 'ç‚®å°', desc: 'èŒƒå›´æ£€æµ‹ï¼Œè¿ç»­å°„å‡»(2æ¬¡å£°çº³å¯ç˜«ç—ª)', color: '#aa44ff' },
    { type: 'sniper', name: 'ç‹™å‡»æ‰‹', desc: 'å…¨å›¾å¬å£°ï¼Œè“„åŠ›ç‹™å‡»(çº¢çº¿é¢„è­¦ï¼Œå£°çº³å¯æ‰“æ–­)', color: '#ff2255' },
    { type: 'hive', name: 'èœ‚å·¢', desc: 'ä¸ç§»åŠ¨ï¼ŒæŒç»­é‡Šæ”¾å°æ€ªç¾¤', color: '#33ff66' },
    { type: 'swarmling', name: 'èœ‚ç¾¤è™«', desc: 'èœ‚å·¢äº§ç‰©ï¼Œè‡ªåŠ¨é”å®šç©å®¶', color: '#66ff88' },
    { type: 'phantom', name: 'å¹»å½±', desc: 'ç©¿å¢™ç§»åŠ¨ï¼ŒåŠéšå½¢', color: '#bb77ff' },
    { type: 'drainer', name: 'å¸èƒ½è€…', desc: 'å¸å–ç©å®¶èƒ½é‡', color: '#33aaff' },
];
// SVG shapes matching actual in-game enemy rendering
function enemySVG(type, color) {
    const s = 30; // viewBox size
    const c = s / 2; // center
    const r = 10; // base radius
    switch (type) {
        case 'drifter': // square
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><rect x="${c-r/2*1.1}" y="${c-r/2*1.1}" width="${r*1.1}" height="${r*1.1}" fill="${color}"/></svg>`;
        case 'hunter': // diamond
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><polygon points="${c},${c-r} ${c+r*0.7},${c} ${c},${c+r} ${c-r*0.7},${c}" fill="${color}"/></svg>`;
        case 'turret': { // hexagon
            let pts = '';
            for (let i = 0; i < 6; i++) {
                const a = (Math.PI * 2 / 6) * i - Math.PI / 6;
                pts += `${c + Math.cos(a) * r},${c + Math.sin(a) * r} `;
            }
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><polygon points="${pts.trim()}" fill="${color}"/></svg>`;
        }
        case 'sniper': // narrow tall triangle
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><polygon points="${c},${c-r*1.2} ${c+r*0.4},${c+r*0.6} ${c-r*0.4},${c+r*0.6}" fill="${color}"/></svg>`;
        case 'hive': { // circle with inner segment lines
            let lines = '';
            for (let i = 0; i < 6; i++) {
                const a = (Math.PI * 2 / 6) * i;
                lines += `<line x1="${c}" y1="${c}" x2="${c + Math.cos(a) * r}" y2="${c + Math.sin(a) * r}" stroke="#227744" stroke-width="1"/>`;
            }
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><circle cx="${c}" cy="${c}" r="${r}" fill="${color}"/>${lines}</svg>`;
        }
        case 'swarmling': // small diamond
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><polygon points="${c},${c-r*0.7} ${c+r*0.45},${c} ${c},${c+r*0.7} ${c-r*0.45},${c}" fill="${color}"/></svg>`;
        case 'phantom': { // wavy circle
            let pts = '';
            for (let i = 0; i < 12; i++) {
                const a = (Math.PI * 2 / 12) * i;
                const wobble = r + Math.sin(i * 1.5) * 2.5;
                pts += `${c + Math.cos(a) * wobble},${c + Math.sin(a) * wobble} `;
            }
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><polygon points="${pts.trim()}" fill="${color}" opacity="0.75"/></svg>`;
        }
        case 'drainer': // circle with swirl arc
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><circle cx="${c}" cy="${c}" r="${r}" fill="${color}"/><path d="M ${c+r*0.5},${c} A ${r*0.5},${r*0.5} 0 1 1 ${c-r*0.5},${c}" fill="none" stroke="#1166cc" stroke-width="1.5"/></svg>`;
        default:
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><circle cx="${c}" cy="${c}" r="${r}" fill="${color}"/></svg>`;
    }
}
function bossSVG(type, color) {
    const s = 30, c = s / 2, r = 11;
    switch (type) {
        case 'satellite': { // octagon
            let pts = '';
            for (let i = 0; i < 8; i++) {
                const a = (Math.PI * 2 / 8) * i - Math.PI / 8;
                pts += `${c + Math.cos(a) * r},${c + Math.sin(a) * r} `;
            }
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><polygon points="${pts.trim()}" fill="none" stroke="${color}" stroke-width="2"/><circle cx="${c-r*0.5}" cy="${c}" r="2" fill="${color}"/><circle cx="${c+r*0.5}" cy="${c}" r="2" fill="${color}"/><circle cx="${c}" cy="${c-r*0.5}" r="2" fill="${color}"/><circle cx="${c}" cy="${c+r*0.5}" r="2" fill="${color}"/></svg>`;
        }
        case 'splitmom': // large pulsing circle
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><circle cx="${c}" cy="${c}" r="${r}" fill="none" stroke="${color}" stroke-width="2"/><circle cx="${c}" cy="${c}" r="${r*0.5}" fill="${color}" opacity="0.5"/></svg>`;
        case 'jammer': { // irregular polygon with static
            let pts = '';
            const verts = [0, 0.8, 1.5, 2.2, 3.0, 3.8, 4.6, 5.4];
            verts.forEach(a => {
                const rr = r * (0.8 + Math.sin(a * 3) * 0.25);
                pts += `${c + Math.cos(a) * rr},${c + Math.sin(a) * rr} `;
            });
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><polygon points="${pts.trim()}" fill="none" stroke="${color}" stroke-width="1.5"/><line x1="${c-3}" y1="${c-2}" x2="${c+3}" y2="${c-2}" stroke="${color}" stroke-width="1" opacity="0.6"/><line x1="${c-2}" y1="${c+2}" x2="${c+4}" y2="${c+2}" stroke="${color}" stroke-width="1" opacity="0.6"/></svg>`;
        }
        default:
            return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}"><circle cx="${c}" cy="${c}" r="${r}" fill="${color}"/></svg>`;
    }
}
const BOSS_GUIDE = [
    { type: 'satellite', name: 'æ ¸å¿ƒå«æ˜Ÿ', desc: 'æ—‹è½¬å…«è¾¹å½¢ï¼Œåå­—å¼¹å¹•', color: '#ff4466' },
    { type: 'splitmom', name: 'åˆ†è£‚æ¯ä½“', desc: 'è¿½è¸ªç©å®¶ï¼Œå—ä¼¤åˆ†è£‚å‡ºçŒæ‰‹', color: '#ff3355' },
    { type: 'jammer', name: 'ä¿¡å·å¹²æ‰°å™¨', desc: 'å‰Šå¼±å£°çº³èŒƒå›´ï¼Œä¸‰å‘å¼¹å¹•', color: '#ddeeff' },
    { type: 'phantomlord', name: 'å¹½çµé¢†ä¸»', desc: 'ç©¿å¢™ç¬ç§»ï¼Œå¬å”¤å¹»å½±', color: '#bb77ff' },
    { type: 'overload', name: 'è¿‡è½½æ ¸å¿ƒ', desc: 'èºæ—‹å¼¹å¹•ï¼ŒäºŒé˜¶æ®µç‹‚æš´', color: '#ff2200' },
];
function renderPauseGuide() {
    const eg = document.getElementById('pauseEnemyGuide');
    eg.innerHTML = '';
    ENEMY_GUIDE.forEach(e => {
        const d = document.createElement('div');
        d.style.cssText = 'background:rgba(255,255,255,0.03);border:1px solid ' + e.color + '33;border-radius:6px;padding:8px 10px;width:110px;text-align:center;';
        d.innerHTML = '<div style="margin-bottom:4px;display:flex;justify-content:center;">' + enemySVG(e.type, e.color) + '</div>'
            + '<div style="font-size:10px;color:' + e.color + ';font-weight:bold;margin-bottom:2px;">' + e.name + '</div>'
            + '<div style="font-size:9px;color:#888;line-height:1.4;">' + e.desc + '</div>';
        eg.appendChild(d);
    });
    const bg = document.getElementById('pauseBossGuide');
    bg.innerHTML = '';
    BOSS_GUIDE.forEach(b => {
        const d = document.createElement('div');
        d.style.cssText = 'background:rgba(255,255,255,0.03);border:1px solid ' + b.color + '44;border-radius:6px;padding:8px 10px;width:140px;text-align:center;';
        d.innerHTML = '<div style="margin-bottom:4px;display:flex;justify-content:center;">' + bossSVG(b.type, b.color) + '</div>'
            + '<div style="font-size:10px;color:' + b.color + ';font-weight:bold;margin-bottom:2px;">' + b.name + '</div>'
            + '<div style="font-size:9px;color:#888;line-height:1.4;">' + b.desc + '</div>';
        bg.appendChild(d);
    });
}
function togglePause() {
    if (!playing) return;
    if (cardSelectActive) return;
    gamePaused = !gamePaused;
    const overlay = document.getElementById('pauseOverlay');
    if (gamePaused) {
        renderPauseGuide();
        overlay.style.display = 'flex';
        overlay.classList.remove('hidden');
        // Pause background music
        if (bgm && !bgm.paused) bgm.pause();
    } else {
        overlay.style.display = 'none';
        overlay.classList.add('hidden');
        // Resume background music
        if (bgm) bgm.play().catch(() => {});
        lastTime = performance.now();
        requestAnimationFrame(loop);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME FLOW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startGame() {
    ensureAudio();
    // Save player name + register in known players list
    // If coming from menu, read input; if from game over, keep current name
    const inputName = $nameInput.value.trim();
    if (inputName) currentPlayerName = inputName;
    if (!currentPlayerName) currentPlayerName = 'UNKNOWN';
    localStorage.setItem('neonEchoPlayerName', currentPlayerName);
    $nameInput.value = currentPlayerName; // sync input for next time
    if (!knownPlayers.includes(currentPlayerName)) {
        knownPlayers.push(currentPlayerName);
        localStorage.setItem('neonEchoPlayers', JSON.stringify(knownPlayers));
        populateNameHistory();
    }
    // Load this player's data
    unlockedAchievements = JSON.parse(localStorage.getItem('neonEchoAch_' + currentPlayerName) || '[]');
    best = parseInt(localStorage.getItem('neonEchoBest_' + currentPlayerName)) || 0;
    $bestVal.textContent = best;

    player = new Player();
    pulses = []; bullets = []; enemies = []; particles = [];
    energyOrbs = []; supplyCrates = []; pickupTexts = [];
    cardCrates = []; walls = []; specialWalls = [];
    score = 0; gameTime = 0; frameCount = 0;
    spawnTimers = {}; crateTimer = 5;
    cardCrateTimer = 12;
    cardSelectActive = false;
    sonarSlowFactor = 1;
    wallPhase = 0;
    activeBoss = null; bossWarningTimer = 0;
    for (const entry of BOSS_SCHEDULE) entry.spawned = false;
    shownEvolveTier = 0;
    breathEvents = [false, false, false];
    shakeTimer = 0; damageFlash = 0; pickupFlashTimer = 0;
    playerNoiseRadius = 0;
    mouse.x = W / 2; mouse.y = H / 2;
    resetSessionStats();
    sessionNewAchievements = [];
    achieveCheckTimer = 0;

    $menuStart.classList.add('hidden');
    $menuOver.classList.add('hidden');
    document.getElementById('cardOverlay').classList.add('hidden');
    document.getElementById('achievePanel').classList.add('hidden');
    document.getElementById('leaderPanel').classList.add('hidden');
    $hud.classList.remove('hidden');

    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, W, H);

    // Pre-spawn a few drifters + initial supply crates
    for (let i = 0; i < 5; i++) spawnEnemy('drifter');
    for (let i = 0; i < 2; i++) spawnSupplyCrate();

    playing = true;
    lastTime = performance.now();
    if (bgmStopTimeout) { clearTimeout(bgmStopTimeout); bgmStopTimeout = null; }
    playBGM();
    requestAnimationFrame(loop);
}

function gameOver() {
    playing = false;
    cardSelectActive = false;
    activeBoss = null;
    document.getElementById('cardOverlay').classList.add('hidden');
    spawnParticles(player.x, player.y, 15, '#fff', 3);
    SFX.death();
    // Fade out BGM over 2 seconds then stop
    fadeBGM(0, 2);
    bgmStopTimeout = setTimeout(() => stopBGM(), 2200);
    if (score > best) {
        best = score;
        localStorage.setItem('neonEchoBest_' + currentPlayerName, best);
    }
    // Final achievement check
    checkAchievements();
    // Add to leaderboard (only updates if new best for this name)
    addToLeaderboard(currentPlayerName, score, gameTime);
    // Render results
    $finalScore.textContent = score;
    document.getElementById('finalTime').textContent = Math.floor(gameTime);
    analyzeBlackBoxLocal();
    renderLeaderboard('overLeaderboard', currentPlayerName);
    // Render session achievements
    const $overAch = document.getElementById('overAchievements');
    if (sessionNewAchievements.length > 0) {
        let html = '<div style="font-size:10px;color:#ffcc00;letter-spacing:2px;text-align:center;">â€” æœ¬å±€è§£é” â€”</div><div class="over-ach-wrap">';
        sessionNewAchievements.forEach((ach, i) => {
            html += '<div class="over-ach-item" style="animation-delay:' + (i * 0.15) + 's"><span class="ach-i">' + ach.icon + '</span>' + ach.name + '<span class="ach-d">' + ach.desc + '</span></div>';
        });
        html += '</div>';
        $overAch.innerHTML = html;
        SFX.achieve();
    } else {
        $overAch.innerHTML = '';
    }
    $hud.classList.add('hidden');
    $menuOver.classList.remove('hidden');
}

function returnToMenu() {
    // From game over screen â†’ go to start menu
    if (!playing && $menuOver.style.display !== 'none' && !$menuOver.classList.contains('hidden')) {
        $menuOver.classList.add('hidden');
        $menuStart.classList.remove('hidden');
        return;
    }
    // From playing (paused or not) â†’ stop game, go to start menu
    if (playing) {
        playing = false;
        cardSelectActive = false;
        gamePaused = false;
        activeBoss = null;
        document.getElementById('pauseOverlay').style.display = 'none';
        document.getElementById('pauseOverlay').classList.add('hidden');
        document.getElementById('cardOverlay').classList.add('hidden');
        // Save score if it's a new best
        if (score > best) {
            best = score;
            localStorage.setItem('neonEchoBest_' + currentPlayerName, best);
            $bestVal.textContent = best;
        }
        if (gameTime > 5) addToLeaderboard(currentPlayerName, score, gameTime);
        stopBGM();
        if (bgmStopTimeout) { clearTimeout(bgmStopTimeout); bgmStopTimeout = null; }
        $hud.classList.add('hidden');
        $menuOver.classList.add('hidden');
        $menuStart.classList.remove('hidden');
    }
    // Close achievement/leaderboard panels if open
    document.getElementById('achievePanel').classList.add('hidden');
    document.getElementById('leaderPanel').classList.add('hidden');
}

$bestVal.textContent = best || 'â€”';
</script>
</body>
</html>
